<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title>Directed Acyclic Word Graph or DAWG</title>
	<style> body {font-size: 21px;} </style>
	<style type="text/css">
	<!--
	TD{font-family: Arial; font-size: 21px;}
	--->
	</style>
	<style>
	.keyword{color:rgb(0,0,255);}
	.comment{color:rgb(0,128,0);}
	.pp{color:rgb(0,0,255);}
	</style>
	<style type="text/css">
	<!--
	caption{font-family: courier; font-size: 30px; font-weight: bold; color: #008000;}
	--->
	</style>
	
	<style type="text/css">
	<!--
	H3{font-family: arial; font-size: 36px; font-weight: bold; color: #000000;}
	--->
	</style>

</head>

<body>

<a name="top"></a>

<font color="#008000">
<h1 align="CENTER"> Directed Acyclic Word Graph or DAWG </h1> 
</font>
<hr width="90%">

<center>Original Page Published On:&nbsp;&nbsp;Monday, April 11, 2011.</center>

<h4 align="CENTER">
|&nbsp;<a href="#introduction">Introduction</a>&nbsp;|
|&nbsp;<a href="#structure">The&nbsp;Blitzkrieg&nbsp;DAWG&nbsp;Structure</a>&nbsp;|
|&nbsp;<a href="#creation">Blitzkrieg&nbsp;DAWG&nbsp;Genesis</a>&nbsp;|
|&nbsp;<a href="#implement">C&nbsp;&amp;&nbsp;Java&nbsp;Implementation</a>&nbsp;|
|&nbsp;<a href="http://pages.pathcom.com/%7Evadco/cwg.html">Caroline&nbsp;Word&nbsp;Graph&nbsp;or&nbsp;CWG</a>&nbsp;|
|&nbsp;<a href="http://pages.pathcom.com/%7Evadco/deep.html">Dense&nbsp;Boggle&nbsp;Board&nbsp;Solution&nbsp;-&nbsp;Full&nbsp;Disclosure</a>&nbsp;|
|&nbsp;<a href="#contact">Contact&nbsp;Information</a>&nbsp;|</h4>

<hr width="90%">
<a name="introduction"></a>
<font color="#008000">
<h2 align="CENTER">Introduction</h2>
</font>

<center><h3><b> 474 KB Compressed-Postfix Boolean-Word-Graph For The English Language</b></h3></center>

<center>

<b>TWL06 Lexicon Engine</b>&nbsp;&nbsp;

<script src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/deployJava.js"></script>
<script>        
var url = "http://www.pathcom.com/~vadco/Engine.jnlp";
deployJava.createWebStartLaunchButton(url, '1.6.0');
</script><a href='javascript:if%20(!deployJava.isWebStartInstalled("1.6.0"))%20{if%20(deployJava.installLatestJRE())%20{if%20(deployJava.launch("http://www.pathcom.com/~vadco/Engine.jnlp"))%20{}}}%20else%20{if%20(deployJava.launch("http://www.pathcom.com/~vadco/Engine.jnlp"))%20{}}' onmouseover="window.status=''; return true;"><img src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/webstart.png" border="0"></a>
<script language="JavaScript" src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/s_code_remote.html"></script>

&nbsp;&nbsp;&nbsp;It's Java.&nbsp;&nbsp;Just deal with it.
</center>
<br>
<hr width="90%">
<center><h3><b>Blitzkrieg Attack Algorithm</b></h3></center>
<center><b>*This algorithm is dedicated to Michael Czajka, a talented colleague, and fallen comrade.</b></center>
<br>
<center>6 Major Concerns Addressed On:&nbsp;&nbsp;Monday, December 30, 2011.</center>
<br>
<b>1) First Concern:</b> A user defined character set of up to 256 letters is now supported.  This accomodates certain foreign lexicons.
<br>
<br>
<b>2) Second Concern:</b> Allowance for medium sized word lists. 2^22 (4,194,304) DAWG-Node count is the new upper limit.
<br>
<br>
<b>3) Third Concern:</b> Superior "ReplaceMeWith" scheme.
<br>
<br>
<b>4) Fourth Concern:</b> The use of CRC-Digest calculation, "Tnode" segmentation, and stable group sorting render DAWG creation <b>INSTANTANEOUS</b>.&nbsp;&nbsp;The
 Blitzkrieg algorithm generates a DAWG encoding so fast, that it might 
very well already be a Google trade secret, the kind of performance one 
might come to expect if you found a way to get Ken Thompson, Dennis 
Ritchie, and even the Great John von Neumann to build it for you.
<br>
<br>
<b>5) Fifth Concern:</b> Certain Graph configurataions led the previous version of this program to crash...  <b>NO MORE</b>.
<br>
<br>
<b>6) Sixth Concern:</b> A new DAWG int-node format is used to reduce the number of bitwise operations + add direct "char" extraction.
<font color="#008000">
<h2 align="CENTER">Special thanks to the following programmers for their input:</h2>
</font>
<b>Rasmus Andersson</b> - Motivated me to code the Blitzkrieg Algorithm when he found a wordlist which crashed the Traditional_Dawg_Creator code.<br>
<br>
<b>Jerzy Chalupski</b> - Alerted me to the potential of how CRC 
calculation could boost speed during the graph reduction analysis.  This
 is his object oriented C++ documentation; <a href="https://github.com/chalup/dawggenerator">https://github.com/chalup/dawggenerator</a>.&nbsp;&nbsp;It's
 not going to win him the Nobel Prize, but he must be doing something 
right, because the CRC idea is magnificent.
<br>
<br>
<b>Edouard de Labareyre</b> - Questions about French words.
<br>
<b>Joakim Laumann</b> - Questions about Norwegian words.
<br>
<b>Oskar Groth</b> - Questions about Swedish words.
<br>

<p>* The next program I write will use what I have learned here to solve
 a high profile NP-Complete problem.&nbsp;&nbsp;With this type of 
accomplishment, I hope to bypass the multi-phase Google interview 
process, and conduct a single Pow-Wow interview session with Ken 
Thompson, Google's Most Distinguished Engineer.</p>

<hr width="90%">

<p>&nbsp;&nbsp;&nbsp;&nbsp;A directed acyclic word graph is simply a 
data structure that stores a lexicon of character strings or words in a 
compressed array of properly encoded integers.&nbsp;&nbsp;It is a great 
place to begin an investigation of lexicon-data-structure optimization, 
but ultimately, the traditional DAWG's limitations due to list-scrolling
 and Boolean return values will lead the elite-optimization-programmer 
to the more advanced <a href="http://pages.pathcom.com/%7Evadco/cwg.html">Caroline Word Graph</a>.&nbsp;&nbsp;Any process that makes use of the <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAWG</a> data structure traverses it as though it were a list-style trie.&nbsp;&nbsp;A <a href="http://en.wikipedia.org/wiki/Trie">TRIE</a>
 is a data tree where every prefix is shared to reduce the amount of 
space required to store a lexicon and reduce the time required to 
�retrieve� a word.&nbsp;&nbsp;A Trie using explicit pointers, for each 
child node, becomes something like an enormous sparse matrix, populated 
mostly with zeros.&nbsp;&nbsp;Progression to a list-style Trie reduces 
the structure's size and retains the added benefit of a one-to-one ratio
 between words and End_Of_Word_Flags.&nbsp;&nbsp;The compromise is that 
finding a child node requires scrolling through a list of 
nodes.&nbsp;&nbsp;The DAWG data structure results from an attempt to 
reduce the size of a list-style Trie while maintaining the fast search 
times.&nbsp;&nbsp;This is carried out by attempting to replace identical
 postfix structures.&nbsp;&nbsp;It is critical to understand that all 
words ending with an �s� or �es� or �tion� or �istic� do NOT necessarily
 use the same nodes in the DAWG data structure.&nbsp;&nbsp;The example 
below will clarify this salient DAWG-property:
</p>
Consider the trie of 11 words stored in 23 nodes:
<br>
<br>

<table align="CENTER" cellspacing="5" cellpadding="5" bordercolor="008000" border="8">

<tbody><tr>
<td <ul="" type="square">
<li> 1.	 ablate
</li><li> 2.	 ablated
</li><li> 3.	 ablates
</li><li> 4.	 ablating
</li><li> 5.	 ablation
</li><li> 6.	 ablations
</li><li> 7.	 abject
</li><li> 8.	 abjection
</li><li> 9.	 abjections
</li><li> 10. abjectly
</li><li> 11. abjectness

</li></td>
<td <body=""><a href="http://pages.pathcom.com/%7Evadco/DAWG23%20-%20Big.jpg"><img src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/DAWG23%2520-%2520Small.jpg"></a> </td>
</tr>

</tbody></table>


<br>
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;It can be clearly observed that because there
 is no �e� following the �t� in �abject,� the �t� contained in "ablate" 
can not be the same node in a DAWG.&nbsp;&nbsp;Hence the �tion� shared 
by each word does not share the same postfix structure, and must not be 
the same path in the DAWG.&nbsp;&nbsp;It is true however that the �ons� 
structure will be shared by both words in a DAWG.&nbsp;&nbsp;That is 
only true for the optimal DAWG because the �ons� part of �abjections� is
 a direct child.&nbsp;&nbsp;&nbsp;&nbsp;A graphical representation is 
presented above.&nbsp;&nbsp;It is not computer generated.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Due to the objective of space reduction being
 the essence of a DAWG, it is important to note that the minimal number 
of nodes will not produce the smallest DAWG.&nbsp;&nbsp;Space size of a 
data structure is given by the following equation:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;STRUCTURE SIZE = (NUMBER OF NODES) x (SIZE OF EACH NODE)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The size of each node in computer science is 
not arbitrary.&nbsp;&nbsp;Data structures have a minimum unit size of 
4-Bytes, and there are 1-Byte and 2-Byte basic integer types as well, 
but 3-Byte basic integer types do not exit.&nbsp;&nbsp;Standard C treats
 this as divine truth.&nbsp;&nbsp;Therefore if the size of each node can
 be reduced by half and the number of nodes does not double as a result,
 the total structure size has fallen.&nbsp;&nbsp;Replacing the Trie's 
Next pointer with breadth-first array population and a single Bit-Flag 
is why a DAWG-Node can fit into one 32-Bit integer.&nbsp;&nbsp;It is 
unfortunate that 3-Byte integers are not supported by modern processor 
architectures, because for TWL06, each int-node can be squeezed into 
3-Bytes.&nbsp;&nbsp;There are 2 ways to make this happen even still, but
 they both require additional bit-manipulation instructions, so they can
 hardly be justified:</p>
<b>1)</b> The DAWG structure can be housed in an array of short integers
 plus an array of chars.&nbsp;&nbsp;In this scheme, the first-child 
index value would span into both parts of the structure, and so 
additional masking and shifting would be required to extract information
 from each node.&nbsp;&nbsp;If the number of nodes in your DAWG can fit 
into 16 bits, then this 3-Byte segmentation is the way to go.
<br>
<br>
<b>2)</b> The DAWG structure can be housed in one array of 
chars.&nbsp;&nbsp;In this scheme, indexing each node in the structure 
requires multiplying by 3, which can be accomplished by the following 
equation:&nbsp;&nbsp;<b>Index = Index&lt;&lt;1 + Index;</b>&nbsp;&nbsp;Integer
 casting is then needed, as well as one additional 
bit-mask.&nbsp;&nbsp;The one equation involves 2 basic operations plus 
an assignment, so although you are saving 25% in data space, you are 
paying for it in extra instructions.&nbsp;&nbsp;If your processor is 
either lacking in data cache, or it contains native 3-Byte hardware 
instructions, then this is the way to go, otherwise avoid the additional
 computation.
<br>
<br>

<hr width="90%">
<a name="structure"></a>
<font color="#008000">
<h2 align="CENTER">The Blitzkrieg DAWG Structure</h2>
</font>



<p>&nbsp;&nbsp;&nbsp;&nbsp;A DAWG-Node can be seen as containing a 
letter, references to its children, and a Flag indicating the completion
 of a word.&nbsp;&nbsp;Now, because a single character does not 
represent an entire word, or key, computer science would not refer to (a
 single letter, a flag, and pointers) as a �node�.&nbsp;&nbsp;Rather, 
each character would be called an "edge".&nbsp;&nbsp;In order to 
simplify this DAWG treatment, the "edge" convention has been disposed 
of.&nbsp;&nbsp;A node in a DAWG is now defined as (an Explicit-Letter, 
an index to the First-Child node, an End-Of-Word flag, and an 
End-Of-List flag.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;We are attempting to minimize the size of a 
single �node� so that it will be less than or equal to 32 bits while at 
the same time keeping the number of nodes low enough to justify the 
reduction of information in each node.&nbsp;&nbsp;For now, this is a 
double-edged sword, because it forces graph traversal to scroll through 
Child-Lists.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;In short, the 26 letters in the English 
alphabet require 5-bits to store a Letter-Index, but since the space is 
available, we shall use a full 8-Bit Byte to store an Explicit-Letter, 
with the potential to accomodate languages with up to 256 unique 
characters.&nbsp;&nbsp;Additionally, no extra instruction will be needed
 to turn a Letter-Index into a usable char.&nbsp;&nbsp;Nodes need a 
single bit to store an End-Of-Word flag.&nbsp;&nbsp;A list of children 
should make sense because this would reduce the number of references for
 children to just two.&nbsp;&nbsp;One reference is for the First-Child 
of the list below a node, and a second reference is for Next-Node in the
 current list.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Experimentation has shown that there is one 
further reduction that will ultimately reduce the size of the final 
DAWG, but increase the number of nodes slightly.&nbsp;&nbsp;The DAWG 
nodes will be stored into a contiguous array, where the Next-Node 
reference will be replaced by a single End-Of-List bit-flag, where the 
Next-Node in a list is assumed to be the next element in the array 
unless the End-Of-List bit-flag is set.&nbsp;&nbsp;This will increase 
the total number of nodes required because the only DirectChild nodes 
will be tested for emilination, to keep the list structures intact, in 
other words, the first node in a Child-List is the only type of node 
where elimination can begin.&nbsp;&nbsp;Clearly, every node in the 
Next-List and every node below a redundant node will also be removed, so
 there will not be as much of a discrepancy in node elimination as one 
would expect, given this strict condition.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;This "Child Reference Only" step is far from 
trivial, as it requires a �breadth� first tree 
traversal.&nbsp;&nbsp;This type of traversal is required to enter all of
 the temporary Tnodes into a 4D array which holds similar groups of 
pointers which will be sorted using 3 comparison 
values.&nbsp;&nbsp;Also, this type of traversal is required once more 
when assigning indexes to all of the remaining 
Tnodes.&nbsp;&nbsp;Complexity arises from the requirement of a secondary
 data structure know as a queue, so that traversal is carried out level 
by level, as opposed to the standard recursive �depth-first" traversal.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;With ten bits spoken for, that leaves 22 bits
 remaining for the First-Child index.&nbsp;&nbsp;22-Bits translates into
 a maximum number of array elements equal to 4,194,304.&nbsp;&nbsp;This 
value exceeds the number of nodes needed to store TWL06 by a large 
margin.&nbsp;&nbsp;TWL06 fits into 121,174 nodes (including the Null 
zero node), which requires only 17-bits.&nbsp;&nbsp;This number only 
reaches 123,670 nodes using a less complex algorithm, which used to be 
presented on this very page.&nbsp;&nbsp;Every node is a 4-Byte integer, 
so that is where 474 KB, presented above, comes from.&nbsp;&nbsp;At less
 than a half Mega Byte to store a fast Boolean graph of the English 
Language, the traditional DAWG encoding has its appeal.&nbsp;&nbsp;It 
would require almost double this space to store a DAWG with a minimal 
node count.&nbsp;&nbsp;Learn this data structure, and then migrate to 
the more advanced <a href="http://pages.pathcom.com/%7Evadco/cwg.html">Caroline Word Graph</a>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The Blitzkrieg encoding places an 
Explicit-Letter into the first Byte of each Node-Integer, followed by 
the End-Of-List flag, followed by the End-Of-Word flag, and the final 22
 most significant bits hold the First-Child index value, which can now 
be extracted using a single Bit-Shift.&nbsp;&nbsp;Below, I have included
 a printout of what each int-node looks like and the macros used to 
extract member data from them.</p>

[1111111111111111111111|0|0|00000000] - CHILD_INDEX_BIT_MASK<br>
[0000000000000000000000|1|0|00000000] - END_OF_WORD_BIT_MASK<br>
[0000000000000000000000|0|1|00000000] - END_OF_LIST_BIT_MASK<br>
[0000000000000000000000|0|0|11111111] - LETTER_BIT_MASK<br>
<br>
#define CHILD_BIT_SHIFT 10<br>
#define EOW_BIT_MASK 0X00000200<br>
#define EOL_BIT_MASK 0X00000100<br>
#define LETTER_BIT_MASK 0X000000FF<br>
<br>
#define DAWG_LETTER(thearray, theindex) (thearray[theindex]&amp;LETTER_BIT_MASK)<br>
#define DAWG_EOW(thearray, theindex) (thearray[theindex]&amp;EOW_BIT_MASK)<br>
#define DAWG_NEXT(thearray, theindex) ((thearray[theindex]&amp;EOL_BIT_MASK)? 0: theindex + 1)<br>
#define DAWG_CHILD(thearray, theindex) (thearray[theindex]&gt;&gt;CHILD_BIT_SHIFT)<br>
<br>
<br>


<hr width="90%">
<a name="creation"></a>
<font color="#008000">
<h2 align="CENTER">Blitzkrieg DAWG Genesis</h2>
</font>


<p>&nbsp;&nbsp;&nbsp;&nbsp;When creating a DAWG encoding with the 
Blitzkrieg_Trie_Attack algorithm, it will seem as though you have 
activated a time machine and transported the new DAWG data file into the
 PAST.&nbsp;&nbsp;Yes, the Blitzkrieg algorithm is that much faster than
 the older versions of Traditional_Dawg_Creator code, which took several
 minutes to compute TWL06 using even a 3Ghz multi-core 
PC.&nbsp;&nbsp;The 17 steps are listed below.&nbsp;&nbsp;Commented 
C-code is also provided, and will assist anyone who is interested in 
understanding how these steps actually work.
<br>
<br>


</p><ul type="square">
<li> <b>Step 0:</b>&nbsp;&nbsp;Allocate the framework for the intermediate Array-Data-Structure..
</li><li> <b>Step 1:</b>&nbsp;&nbsp;Create a temporary list-style Trie and begin filling it with the words from "Word-List.txt".
</li><li> <b>Step 2:</b>&nbsp;&nbsp;Calculate the InternalValues comparison integers for each Tnode.

<p>- The InternalValues integer contains all of the unique internal comparison values of each Tnode in one number.</p>

</li><li> <b>Step 3:</b>&nbsp;&nbsp;Eliminate recursion by calculating the recursive CrcDigest for each Tnode.

<p>- The CrcDigest value is calculated by using the InternalValues of 
each Tnode, and then building a longer data-message with information 
gathered from all Child nodes and Next nodes, seperated by pre-defined 
cypher integers.&nbsp;&nbsp;Tnodes without any Child or Next lists 
simply copy their InternalValues into their CrcDigest.</p>

</li><li> <b>Step 4:</b>&nbsp;&nbsp;Count Tnodes into 780 groups, segmented by MaxChildDepth, Letter, and DirectChild.
</li><li> <b>Step 5:</b>&nbsp;&nbsp;Initial Tnode counting is complete, so display the results:
</li><li> <b>Step 6:</b>&nbsp;&nbsp;Allocate a 4-D array of Tnode pointers to tag redundant Tnodes for replacement.
</li><li> <b>Step 7:</b>&nbsp;&nbsp;Populate the 4 dimensional Tnode pointer array, keeping DirectChild nodes closer to the end.
</li><li> <b>Step 8:</b>&nbsp;&nbsp;Use the stable Merge-Sort algorithm to sort [MaxChildDepth][LetterIndex] groups by CrcDigest values.
</li><li> <b>Step 9:</b>&nbsp;&nbsp;Tag entire Tnode branch structures as Dangling - Elimination begins with DirectChild Tnodes and filters down:

<p>- The very heart of DAWG genesis, where the Blitzkrieg shines with CRC, and Tnode Grouping.<br>
- Seperate groups exist for each [MaxChildDepth]-[LetterIndex] pair.<br>
- Groups of similar Tnodes, are now sorted by 3 values, [BreadthFirst], [DirectChild], [CrcDigest].<br>
- This Blitzkrieg Scheme means that each redundant Tnode patch will directly follow its living Tnode replacement.</p>

</li><li> <b>Step 10:</b>&nbsp;&nbsp;Count the number of living Tnodes by traversing the Raw-Trie to check the Dangling numbers.
</li><li> <b>Step 11:</b>&nbsp;&nbsp;Using the BlitzkriegTrieAttack, substitute Dangling Tnodes with internal "ReplaceMeWith" values.
</li><li> <b>Step 12:</b>&nbsp;&nbsp;Blitzkrieg Attack is victorious, so assign array indicies to all living Tnodes using a Breadth-First-Queue.
</li><li> <b>Step 13:</b>&nbsp;&nbsp;Populate the new Working-Array-Dawg
 structure, used to verify validity and create the final 
integer-graph-encodings.&nbsp;&nbsp;Then verify that all 3 Tnode 
counting methods yield the same count.
</li><li> <b>Step 14:</b>&nbsp;&nbsp;Creation of the traditional-DAWG is complete, so store it in a binary file for use.
</li><li> <b>Step 15:</b>&nbsp;&nbsp;Output a text file with all the node information explicitly layed out.
</li><li> <b>Step 16:</b>&nbsp;&nbsp;Display the Mask-Format for the DAWG int-nodes:
</li></ul>

<hr width="90%">
<a name="implement"></a>
<font color="#008000">
<h2 align="CENTER">C &amp; Java Implementation</h2>
</font>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Due to popular demand, there are Four 
versions of DAWG C-code published on this page.&nbsp;&nbsp;The oldest, 
more-basic code, the newest Blitzkrieg code, and two intermediate 
steps.&nbsp;&nbsp;Download the untampered with files 
below.&nbsp;&nbsp;The code being displayed is the dazzling Blitzkrieg 
Genesis code and a WildCard anagrammer.&nbsp;&nbsp;The C-code compiles 
just fine with "gcc -O3", so it works in Linux, and Windows using 
Cygwin.&nbsp;&nbsp;If you have an "Apple", I suggest that you decide to 
buy a real computer next time.&nbsp;&nbsp;For those who can tolerate 
Java, source code for the old web-start-app is also available:</p>

<b>Latest Blitzkrieg C-code:</b><br>
----------------------------------------------------------------------------<br>
1) <a href="http://pages.pathcom.com/%7Evadco/Word-List.txt">Word-List.txt</a> - TWL06 word list in a correct Windows format.<br>
2) <a href="http://pages.pathcom.com/%7Evadco/Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c">Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c</a> - Blitzkrieg DAWG Genesis C-code.<br>
3) <a href="http://pages.pathcom.com/%7Evadco/CRC-32.dat">CRC-32.dat</a> - Byte-wise CRC-32 data file.<br>
4) <a href="http://pages.pathcom.com/%7Evadco/Blitzkrieg_Functionality_Test.c">Blitzkrieg_Functionality_Test.c</a> - Test the new Blitzkrieg DAWG.<br>
5) <a href="http://pages.pathcom.com/%7Evadco/Compile-CRC-32-Lookup-Table.c">Compile-CRC-32-Lookup-Table.c</a> - Code used to generate a CRC lookup table.<br>
<br>
<br>
<b>Old C-code:</b><br>
----------------------------------------------------------------------------<br>
1) <a href="http://pages.pathcom.com/%7Evadco/Word-List.txt">Word-List.txt</a> - TWL06 word list in a correct Windows format.<br>
2) <a href="http://pages.pathcom.com/%7Evadco/TraditionalDawgCreatorUpdate.c">TraditionalDawgCreatorUpdate.c</a> -  The old Traditional-DAWG Creator C-code.<br>
3) <a href="http://pages.pathcom.com/%7Evadco/TraditionalDawgCreator.c">TraditionalDawgCreator.c</a> - The older Traditional-DAWG Creator C-code.<br>
4) <a href="http://pages.pathcom.com/%7Evadco/TraditionalDawgAnagrammer.c">TraditionalDawgAnagrammer.c</a> - DAWG functionality demonstrator C-code.<br>
<br>
<br>
<b>Older C-code:</b><br>
----------------------------------------------------------------------------<br>
1) <a href="http://pages.pathcom.com/%7Evadco/Lexicon.txt">Lexicon.txt</a> - TWL06 Scrabble word list in proper text file format<br>
2) <a href="http://pages.pathcom.com/%7Evadco/GoogleDawgCreatorSubmit.c">GoogleDawgCreatorSubmit.c</a> - The even older DAWG-creation C code.<br>
3) <a href="http://pages.pathcom.com/%7Evadco/GoogleDawgAnagrammerSubmit.c">GoogleDawgAnagrammerSubmit.c</a> - The DAWG-testing anagram C code.<br>
<br>
<br>
<b>Old Java Web-Start code:</b><br>
----------------------------------------------------------------------------<br>
1) <a href="http://pages.pathcom.com/%7Evadco/Dawg.java">Dawg.java</a> - DAWG functionality code, slanted for use in Java.<br>
2) <a href="http://pages.pathcom.com/%7Evadco/Driver.java">Driver.java</a> - GUI container, a product of NetBeans.<br>
3) <a href="http://pages.pathcom.com/%7Evadco/Traditional_Dawg_For_Word-List.dat">Traditional_Dawg_For_Word-List.dat</a> - TWL06 pre-compiled DAWG data file.<br>
4) <a href="http://pages.pathcom.com/%7Evadco/Engine.jar">Engine.jar</a> - A runnable Jar file via the Eclipse IDE.<br>
5) <a href="http://pages.pathcom.com/%7Evadco/Engine.jnlp">Engine.jnlp</a> - Java-Web-Start launching protocol file.<br>
<br>
<br>
<table align="CENTER" cellspacing="5" cellpadding="5" bordercolor="008000" border="8">
<caption>Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c"</caption>
<tbody><tr>
<td align="LEFT">

<pre style="font-family:courier;font-size:10pt"><span class="comment">// This program will compile a Traditional DAWG encoding from the "Word-List.txt" file.
</span><span class="comment">// Updated on Monday, December 29, 2011.
</span>
<span class="comment">// A graph compression algorithm this FAST is perfectly suited for record-keeping-compression while solving an NP-Complete.
</span>
<span class="comment">// 6 Major concerns addressed:
</span><span class="comment">// 0) A user defined character set of up to 256 letters is now supported.  This accomodates certain foreign lexicons.
</span><span class="comment">// 1) Allowance for medium sized word lists. 2^22 DAWG node count is the new upper limit.
</span><span class="comment">// 2) Superior "ReplaceMeWith" scheme.
</span><span class="comment">// 3) The use of CRC-Digest calculation, "Tnode" segmentation, and stable group sorting render DAWG creation INSTANTANEOUS.
</span><span class="comment">// 4) Certain Graph configurataions led the previous version of this program to crash...  NO MORE.
</span><span class="comment">// 5) A new DAWG int-node format is used to reduce the number of bitwise operations + add direct "char" extraction.
</span>
<span class="comment">// "Word-List.txt" is a text file with the number of words written on the very first line, and 1 word per line after that.
</span><span class="comment">// The words are case-insensitive for English letters, and the text file may have Windows or Linux format.
</span><span class="comment">// *** MAX is the length of the longest word in the list. Change this value.
</span><span class="comment">// *** MIN is the length of the shortest word in the list.  Change this value.
</span>
<span class="comment">// Include the big-three header files.
</span><span class="pp">#include</span> &lt;stdlib.h&gt;
<span class="pp">#include</span> &lt;stdio.h&gt;
<span class="pp">#include</span> &lt;string.h&gt;

<span class="comment">// General high-level program constants.
</span><span class="pp">#define</span> MERGE_SORT_THRESHOLD 1
<span class="pp">#define</span> MIN 2
<span class="pp">#define</span> MAX 15
<span class="pp">#define</span> SIZE_OF_CHARACTER_SET 26
<span class="pp">#define</span> INPUT_LIMIT 35
<span class="pp">#define</span> LOWER_IT 32
<span class="pp">#define</span> TEN 10
<span class="pp">#define</span> INT_BITS 32
<span class="pp">#define</span> CHILD_BIT_SHIFT 10
<span class="comment">// CHILD_INDEX_BIT_MASK is designed NEVER to be used.
</span><span class="pp">#define</span> CHILD_INDEX_BIT_MASK 0XFFFFFC00
<span class="pp">#define</span> END_OF_WORD_BIT_MASK 0X00000200
<span class="pp">#define</span> END_OF_LIST_BIT_MASK 0X00000100
<span class="pp">#define</span> LETTER_BIT_MASK 0X000000FF
<span class="pp">#define</span> CHILD_CYPHER 0X1EDC6F41
<span class="pp">#define</span> NEXT_CYPHER 0X741B8CD7
<span class="pp">#define</span> TWO_UP_EIGHT 256
<span class="pp">#define</span> LEFT_BYTE_SHIFT 24
<span class="pp">#define</span> BYTE_WIDTH 8

<span class="comment">// C requires a boolean variable type so use C's typedef concept to create one.
</span><span class="keyword">typedef</span> <span class="keyword">enum</span> { FALSE = 0, TRUE = 1 } Bool;
<span class="keyword">typedef</span> Bool* BoolPtr;

<span class="comment">// The lexicon text file.
</span><span class="pp">#define</span> RAW_LEXICON "Word-List.txt"

<span class="comment">// This program will create "1" binary-data file for use, and "1" text-data file for inspection.
</span><span class="pp">#define</span> TRADITIONAL_DAWG_DATA "Traditional_Dawg_For_Word-List.dat"
<span class="pp">#define</span> TRADITIONAL_DAWG_TEXT_DATA "Traditional_Dawg_Explicit_Text_For_Word-List.txt"

<span class="comment">// An explicit table-lookup CRC calculation will be used to identify unique graph branch configurations.
</span><span class="pp">#define</span> LOOKUP_TABLE_DATA "CRC-32.dat"

<span class="keyword">unsigned</span> <span class="keyword">int</span> TheLookupTable[TWO_UP_EIGHT];

<span class="comment">// Lookup tables used for node encoding and number-string decoding.
</span><span class="keyword">const</span> <span class="keyword">int</span> PowersOfTwo[INT_BITS] = { 0X1, 0X2, 0X4, 0X8, 0X10, 0X20, 0X40, 0X80, 0X100, 0X200, 0X400, 0X800,
 0X1000, 0X2000, 0X4000, 0X8000, 0X10000, 0X20000, 0X40000, 0X80000, 0X100000, 0X200000, 0X400000, 0X800000, 0X1000000,
 0X2000000, 0X4000000, 0X8000000, 0X10000000, 0X20000000, 0X40000000, 0X80000000 };
 
<span class="keyword">const</span> <span class="keyword">int</span> PowersOfTen[TEN] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> CharacterSet[SIZE_OF_CHARACTER_SET] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
 
 <span class="comment">// Some word lists will contain letters that NO words begin with.  Place "0"s in the corresponding positions.
</span><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> EntryNodeIndex[SIZE_OF_CHARACTER_SET] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
 20, 21, 22, 23, 24, 25, 26 };

<span class="comment">// This simple function clips off the extra chars for each "fgets()" line.  Works for Linux and Windows text format.
</span><span class="keyword">void</span> CutOffExtraChars(<span class="keyword">char</span> *ThisLine){
    <span class="keyword">if</span> ( ThisLine[strlen(ThisLine) - 2] == '\r' ) ThisLine[strlen(ThisLine) - 2] = '\0';
    <span class="keyword">else</span> <span class="keyword">if</span> ( ThisLine[strlen(ThisLine) - 1] == '\n' ) ThisLine[strlen(ThisLine) - 1] = '\0';
}

<span class="comment">// Returns "FALSE" if "TheWord" contains any character not defined in "CharacterSet", and "TRUE" otherwise.
</span>Bool TestForValidWord(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *TheWord){
    <span class="keyword">int</span> Length = strlen(TheWord);
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">for</span> ( X = 0; X &lt; Length; X++ ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            <span class="keyword">if</span> ( TheWord[X] == CharacterSet[Y] ) <span class="keyword">goto</span> NestedContinue;
        }
        <span class="keyword">return</span> FALSE;
        NestedContinue:;
    }
    <span class="keyword">return</span> TRUE;
}

<span class="comment">// Return the index position of character "ThisChar", as it appears in "CharacterSet", and it must exist in the set.
</span><span class="keyword">unsigned</span> <span class="keyword">char</span> CharToIndexConversion(<span class="keyword">unsigned</span> <span class="keyword">char</span> ThisChar){
    <span class="keyword">int</span> Y;
    <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
        <span class="keyword">if</span> ( ThisChar == CharacterSet[Y] ) <span class="keyword">return</span> Y;
    }
}

<span class="comment">// "TheWord" must consist of valid letters within "CharacterSet".
</span><span class="comment">// This function converts "TheWord" from actual characters into index values and stores them into "TheWordByIndex".
</span><span class="keyword">void</span> LettersToIndexConversion(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *TheWord, <span class="keyword">unsigned</span> <span class="keyword">char</span> *TheWordByIndex){
    <span class="keyword">int</span> Length = strlen(TheWord);
    <span class="keyword">int</span> X;
    <span class="keyword">for</span> ( X = 0; X &lt; Length; X++ ) {
        TheWordByIndex[X] = CharToIndexConversion(TheWord[X]);
    }
}

<span class="comment">// Returns the positive "int" rerpresented by "TheNumberNotYet" string.  An invalid "TheNumberNotYet" returns "0".
</span><span class="keyword">int</span> StringToPositiveInt(<span class="keyword">char</span>* TheNumberNotYet){
    <span class="keyword">int</span> Result = 0;
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Length = strlen(TheNumberNotYet);
    <span class="keyword">if</span> ( Length &gt; TEN ) <span class="keyword">return</span> 0;
    <span class="keyword">for</span> ( X = 0; X &lt; Length; X++ ) {
        <span class="keyword">if</span> ( TheNumberNotYet[X] &lt; '0' || TheNumberNotYet[X] &gt; '9' ) <span class="keyword">return</span> 0;
        Result += ((TheNumberNotYet[X] - '0')*PowersOfTen[Length - X - 1 ]);
    }
    <span class="keyword">return</span> Result;
}

<span class="comment">// The "BinaryNode" string must be at least 32 + 5 + 1 bytes in length.  Space for the bits,
</span><span class="comment">// the seperation pipes, and the end of string char.
</span><span class="comment">// This function is used to fill the text file used to inspect the graph created in the first segment of the program.
</span><span class="keyword">void</span> ConvertIntNodeToBinaryString(<span class="keyword">int</span> TheNode, <span class="keyword">char</span> *BinaryNode){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Bit;
    BinaryNode[0] = '[';
    <span class="comment">// 22 Bits, (31--&gt;10) hold the First-Child index.
</span>    Bit = 31;
    <span class="keyword">for</span> ( X = 1; X &lt;= 22; X++, Bit-- ) BinaryNode[X] = (TheNode &amp; PowersOfTwo[Bit])?'1':'0';
    BinaryNode[23] = '|';
    <span class="comment">// Bit 9 holds the End-Of-Word flag.
</span>    BinaryNode[24] = (TheNode &amp; END_OF_WORD_BIT_MASK)?'1':'0';
    BinaryNode[25] = '|';
    <span class="comment">// Bit 8 holds the End-Of-List flag.
</span>    BinaryNode[26] = (TheNode &amp; END_OF_LIST_BIT_MASK)?'1':'0';
    BinaryNode[27] = '|';
    <span class="comment">// The Letter is held in the final 8 bits, (7-&gt;0).
</span>    Bit = 7;
    <span class="keyword">for</span> ( X = 28; X &lt;= 35; X++, Bit-- ) BinaryNode[X] = (TheNode &amp; PowersOfTwo[Bit])?'1':'0';
    BinaryNode[36] = ']';
    BinaryNode[37] = '\0';
}

<span class="comment">//This Function converts any lower case letters inside "RawWord" to capitals, so that the whole string is made of capital letters.
</span><span class="keyword">void</span> MakeMeAllCapital(<span class="keyword">char</span> *RawWord){
    <span class="keyword">int</span> Count = 0;
    <span class="keyword">int</span> Length = strlen(RawWord);
    <span class="keyword">for</span> ( Count = 0; Count &lt; Length; Count++ ) {
        <span class="keyword">if</span> ( RawWord[Count] &gt;= 'a' &amp;&amp; RawWord[Count] &lt;= 'z' ) RawWord[Count] -= LOWER_IT;
    }
}

<span class="comment">// This function performs a Byte-wise lookup table CRC calculation on "NumberOfBytes" Bytes, starting at "DataMessage".
</span><span class="comment">// The Polynomial used to generate the lookup table is CRC-32 = 0X04C11DB7.
</span><span class="comment">// The value returned by the function is the "CRC-Digest".
</span><span class="keyword">unsigned</span> <span class="keyword">int</span> LookupTableCrc(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *DataMessage, <span class="keyword">int</span> NumberOfBytes, Bool Print){
    <span class="keyword">int</span> X;
    <span class="keyword">if</span> ( Print ) {
        printf("|");
        <span class="keyword">for</span> ( X = 0; X &lt; NumberOfBytes; X++ ) {
            printf("%02X", DataMessage[X]);
            <span class="keyword">if</span> ( X%4 == 3 ) printf("|");
        }
        printf(" - Length |%d|\n", NumberOfBytes);
    }
    <span class="comment">// Because looking up "0" in the table returns "0", it is safe to use a table lookup to fill the "WorkingRegister" with its initial "DataMessage" value.
</span>    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WorkingRegister = 0;
    <span class="comment">// Query the "LookupTable" exactly "NumberOfBytes" times.  Perform lookups using the value inside of "WorkingRegister" as the index.
</span>    <span class="comment">// After each table query, "XOR" the value returned by "TheLookupTable" with "WorkingRegister" after pulling in the next Byte of "DataMessage".
</span>    <span class="comment">// "X" is the location of the next data Byte to pull into the calculation.
</span>    <span class="keyword">for</span> ( X = 0; X &lt; NumberOfBytes; X++ ) WorkingRegister = TheLookupTable[WorkingRegister &gt;&gt; LEFT_BYTE_SHIFT] ^ ((WorkingRegister &lt;&lt; BYTE_WIDTH) ^ DataMessage[X]);
    <span class="keyword">if</span> ( Print ) printf("Calculated Digest = |%08X|\n", WorkingRegister);
    <span class="keyword">return</span> WorkingRegister;
}

<span class="comment">/*Trie to Dawg TypeDefs*/</span>
<span class="keyword">struct</span> tnode {
    <span class="keyword">struct</span> tnode* Next;
    <span class="keyword">struct</span> tnode* Child;
    <span class="keyword">struct</span> tnode* ParentalUnit;
    <span class="keyword">struct</span> tnode* ReplaceMeWith;
    <span class="comment">// When populating the DAWG array, you must know the index assigned to each "Child".
</span>    <span class="comment">// "ArrayIndex" Is stored in every node, so that we can mine the information from the Trie.
</span>    <span class="keyword">int</span> ArrayIndex;
    <span class="keyword">int</span> InternalValues;
    <span class="keyword">char</span> DirectChild;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> LetterIndex;
    <span class="keyword">char</span> MaxChildDepth;
    <span class="keyword">char</span> Level;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> NumberOfChildren;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> DistanceToEndOfList;
    <span class="keyword">char</span> Dangling;
    <span class="keyword">char</span> Protected;
    <span class="keyword">char</span> EndOfWordFlag;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> CrcDigest;
    <span class="comment">// To streamline checking if "Protected" "Tnode"s are up for "Dangling", filter "ProtectedUnderCount" up to the root "Tnode"; do it on the fly.
</span>    <span class="keyword">int</span> ProtectedUnderCount;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> tnode Tnode;
<span class="keyword">typedef</span> Tnode* TnodePtr;

<span class="comment">// Functions to access internal "Tnode" members.
</span><span class="keyword">int</span> TnodeArrayIndex(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;ArrayIndex;
}

<span class="keyword">char</span> TnodeDirectChild(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;DirectChild;
}

TnodePtr TnodeNext(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;Next;
}

TnodePtr TnodeChild(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;Child;
}

TnodePtr TnodeParentalUnit(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;ParentalUnit;
}

TnodePtr TnodeReplaceMeWith(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;ReplaceMeWith;
}

<span class="keyword">unsigned</span> <span class="keyword">char</span> TnodeLetterIndex(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;LetterIndex;
}

<span class="keyword">char</span> TnodeMaxChildDepth(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;MaxChildDepth;
}

<span class="keyword">unsigned</span> <span class="keyword">char</span> TnodeNumberOfChildren(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;NumberOfChildren;
}

<span class="keyword">unsigned</span> <span class="keyword">char</span> TnodeDistanceToEndOfList(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;DistanceToEndOfList;
}

<span class="keyword">char</span> TnodeEndOfWordFlag(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;EndOfWordFlag;
}

<span class="keyword">char</span> TnodeLevel(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;Level;
}

<span class="keyword">char</span> TnodeDangling(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;Dangling;
}

<span class="keyword">char</span> TnodeProtected(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;Protected;
}

<span class="keyword">unsigned</span> <span class="keyword">int</span> TnodeCrcDigest(TnodePtr ThisTnode){
    <span class="keyword">return</span> ThisTnode-&gt;CrcDigest;
}

<span class="comment">// Allocate a "Tnode" and fill it with initial values.
</span>TnodePtr TnodeInit(<span class="keyword">unsigned</span> <span class="keyword">char</span> ChapIndex, TnodePtr OverOne, <span class="keyword">char</span> WordEnding, <span class="keyword">char</span> Leveler, <span class="keyword">int</span> StarterDepth, TnodePtr Parent, <span class="keyword">char</span> IsaChild, <span class="keyword">char</span> StartListPosition){
    TnodePtr Result = (Tnode *)malloc(<span class="keyword">sizeof</span>(Tnode));
    Result-&gt;LetterIndex = ChapIndex;
    Result-&gt;ArrayIndex = 0;
    Result-&gt;InternalValues = 0;
    Result-&gt;NumberOfChildren = 0;
    Result-&gt;DistanceToEndOfList = StartListPosition;
    Result-&gt;MaxChildDepth = StarterDepth;
    Result-&gt;Next = OverOne;
    Result-&gt;Child = NULL;
    Result-&gt;ParentalUnit = Parent;
    Result-&gt;Dangling = FALSE;
    Result-&gt;Protected = FALSE;
    Result-&gt;ReplaceMeWith = NULL;
    Result-&gt;EndOfWordFlag = WordEnding;
    Result-&gt;Level = Leveler;
    Result-&gt;DirectChild = IsaChild;
    Result-&gt;CrcDigest = 0;
    Result-&gt;ProtectedUnderCount = 0;
    <span class="keyword">return</span> Result;
}

<span class="comment">// Use this for debugging any program modifications.
</span><span class="keyword">void</span> TnodeOutput(TnodePtr ThisTnode){
    printf("|%c|%d|%d|%d|%X|-|%X|\n", CharacterSet[ThisTnode-&gt;LetterIndex], ThisTnode-&gt;EndOfWordFlag, ThisTnode-&gt;NumberOfChildren,
    ThisTnode-&gt;DistanceToEndOfList, ThisTnode-&gt;InternalValues, ThisTnode-&gt;CrcDigest);
    <span class="keyword">if</span> ( ThisTnode-&gt;Child != NULL ) TnodeOutput(ThisTnode-&gt;Child);
}

<span class="comment">// Modify internal "Tnode" member values.
</span><span class="keyword">void</span> TnodeSetArrayIndex(TnodePtr ThisTnode, <span class="keyword">int</span> TheWhat){
    ThisTnode-&gt;ArrayIndex = TheWhat;
}

<span class="keyword">void</span> TnodeSetChild(TnodePtr ThisTnode, TnodePtr Chump){
    ThisTnode-&gt;Child = Chump;
}
    
<span class="keyword">void</span> TnodeSetNext(TnodePtr ThisTnode, TnodePtr Nexis){
    ThisTnode-&gt;Next = Nexis;
}

<span class="keyword">void</span> TnodeSetParentalUnit(TnodePtr ThisTnode, TnodePtr Parent){
    ThisTnode-&gt;ParentalUnit = Parent;
}

<span class="keyword">void</span> TnodeSetReplaceMeWith(TnodePtr ThisTnode, TnodePtr Living){
    ThisTnode-&gt;ReplaceMeWith = Living;
}

<span class="keyword">void</span> TnodeSetMaxChildDepth(TnodePtr ThisTnode, <span class="keyword">int</span> NewDepth){
    ThisTnode-&gt;MaxChildDepth = NewDepth;
}

<span class="keyword">void</span> TnodeSetDirectChild(TnodePtr ThisTnode, <span class="keyword">char</span> Status){
    ThisTnode-&gt;DirectChild = Status;
}

<span class="keyword">void</span> TnodeFlyEndOfWordFlag(TnodePtr ThisTnode){
    ThisTnode-&gt;EndOfWordFlag = TRUE;
}

<span class="comment">// This statement evaluates to TRUE when the CRC at "one" has a higher value than the CRC at "two".  "one" and "two" are indicies of "arrayone", and "arraytwo".
</span><span class="pp">#define</span> COMPARE_TNODES(arrayone, one, arraytwo, two) ( arrayone[one]-&gt;CrcDigest &gt; arraytwo[two]-&gt;CrcDigest )

<span class="keyword">void</span> TnodeArrayMergeSortRecurse(TnodePtr *OriginalArray, <span class="keyword">int</span> TheSize, TnodePtr *ExtraArray){
    <span class="keyword">int</span> FirstSize = TheSize&gt;&gt;1;
    <span class="keyword">int</span> SecondSize = TheSize - FirstSize;
    <span class="keyword">int</span> FirstIndex = 0;
    <span class="keyword">int</span> SecondIndex = 0;
    <span class="keyword">int</span> InsertIndex = 0;
    TnodePtr *TheFirst = OriginalArray;
    TnodePtr *TheSecond = OriginalArray + FirstSize;
    <span class="comment">// Testing the escape condition before calling "TnodeArrayMergeSort" reduces stack overhead.
</span>    <span class="keyword">if</span> ( FirstSize &gt; MERGE_SORT_THRESHOLD ) TnodeArrayMergeSortRecurse(TheFirst, FirstSize, ExtraArray);
    <span class="keyword">if</span> ( SecondSize &gt; MERGE_SORT_THRESHOLD ) TnodeArrayMergeSortRecurse(TheSecond, SecondSize, ExtraArray);
    <span class="comment">// We can now conclude that the two lists are sorted, so merge them into the "ExtraArray".
</span>    <span class="keyword">while</span> ( FirstIndex &lt; FirstSize &amp;&amp; SecondIndex &lt; SecondSize) {
        <span class="comment">// Using this comparison macro ensures that the sort will be stable.
</span>        <span class="keyword">if</span> ( COMPARE_TNODES(TheSecond, SecondIndex, TheFirst, FirstIndex) ) {
            ExtraArray[InsertIndex] = TheSecond[SecondIndex];
            SecondIndex += 1;
            InsertIndex += 1;
        }
        <span class="keyword">else</span> {
            ExtraArray[InsertIndex] = TheFirst[FirstIndex];
            FirstIndex += 1;
            InsertIndex += 1;
        }
    }
    <span class="comment">// This instruction copies the remaining elements from the unfinished list into the "ExtraArray".
</span>    <span class="keyword">if</span> ( FirstIndex == FirstSize) memcpy(ExtraArray + InsertIndex, TheSecond + SecondIndex, (SecondSize - SecondIndex)*<span class="keyword">sizeof</span>(TnodePtr));
    <span class="keyword">else</span> memcpy(ExtraArray + InsertIndex, TheFirst + FirstIndex, (FirstSize - FirstIndex)*<span class="keyword">sizeof</span>(TnodePtr));
    memcpy(OriginalArray, ExtraArray, TheSize*<span class="keyword">sizeof</span>(TnodePtr));
}

<span class="comment">// After all words have been added to the initial Trie, this function will combine the internal comparison values of "ThisTnode" into its "InternalValues".
</span><span class="keyword">void</span> TnodeCalculateInternalValues(TnodePtr ThisTnode){
    <span class="keyword">char</span> *TheBytes = (<span class="keyword">char</span> *)&amp;(ThisTnode-&gt;InternalValues);
    TheBytes[0] = ThisTnode-&gt;LetterIndex;
    TheBytes[1] = ThisTnode-&gt;NumberOfChildren;
    TheBytes[2] = ThisTnode-&gt;DistanceToEndOfList;
    TheBytes[3] = ((ThisTnode-&gt;MaxChildDepth) &lt;&lt; 1) + ThisTnode-&gt;EndOfWordFlag;
}

<span class="comment">// Recursively calculate all "InternalValues" within a "Tnode" graph.  "ThisTnode" must not be NULL.
</span><span class="keyword">void</span> TnodeCalculateInternalValuesRecurse(TnodePtr ThisTnode){
    TnodeCalculateInternalValues(ThisTnode);
    <span class="keyword">if</span> ( ThisTnode-&gt;Child != NULL ) TnodeCalculateInternalValuesRecurse(ThisTnode-&gt;Child);
    <span class="keyword">if</span> ( ThisTnode-&gt;Next != NULL ) TnodeCalculateInternalValuesRecurse(ThisTnode-&gt;Next);
}

<span class="comment">// The "CrcDigest" of a "Tnode" is heavily based on its "InternalValues".
</span><span class="comment">// Further, when a "Tnode" has a "Child" list OR it is NOT at the end of a list,
</span><span class="comment">// a data message is created using a series of "Child" and "NEXT" "CrcDigest"s.
</span><span class="comment">// These packets of data are seperated by "CYPHER" "int"s to distinguish "Tnode" branch structures.
</span><span class="comment">// Finally, a Byte-Wise Crc-Lookup-Table is used to convert the resulting data-message into a 32 bit "CrcDigest".
</span><span class="keyword">void</span> TnodeCalculateCrcDigest(TnodePtr ThisTnode, Bool Print){
    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> TheMessage[(SIZE_OF_CHARACTER_SET + 2)&lt;&lt;1];
    <span class="keyword">int</span> MessageLength;
    <span class="keyword">int</span> FillSpace;
    <span class="keyword">int</span> X;
    TnodePtr Current;
    <span class="keyword">if</span> ( ThisTnode-&gt;DistanceToEndOfList == 0 ) {
        <span class="comment">// "ThisTnode" is a terminal node, so just use its "InternalValues" as its "CrcDigest".
</span>        <span class="keyword">if</span> ( ThisTnode-&gt;NumberOfChildren == 0 ) {
            ThisTnode-&gt;CrcDigest = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
            <span class="keyword">return</span>;
        }
        <span class="comment">// "ThisTnode" has a "Child" list, but is located at the end of its own "Tnode" list.
</span>        <span class="keyword">else</span> {
            TheMessage[0] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
            TheMessage[1] = CHILD_CYPHER;
            MessageLength = ThisTnode-&gt;NumberOfChildren + 2;
            Current = ThisTnode-&gt;Child;
            <span class="keyword">for</span> ( FillSpace = 2; FillSpace &lt; MessageLength; FillSpace++ ) {
                TheMessage[FillSpace] = Current-&gt;CrcDigest;
                <span class="keyword">if</span> ( TheMessage[FillSpace] == 0 ) printf("ZERO in CRC of Child.\n");
                Current = Current-&gt;Next;
            }
            TheMessage[MessageLength] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
            MessageLength += 1;
            
            <span class="keyword">if</span> ( Print == TRUE ) {
                <span class="keyword">for</span> ( X = 0; X &lt; MessageLength; X++ ) printf("|%08X", TheMessage[X]);
                printf("|\n");
            }
            
            ThisTnode-&gt;CrcDigest = LookupTableCrc((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)TheMessage, MessageLength&lt;&lt;2, Print);
            <span class="keyword">if</span> ( Print == TRUE ) printf("Inherited  Digest = |%X| - Length|%d|\n", ThisTnode-&gt;CrcDigest, MessageLength&lt;&lt;2);
            <span class="keyword">return</span>;
        }
    }
    <span class="comment">// "ThisTnode" has no "Child" list, but has following "Tnode"s in its own list.
</span>    <span class="keyword">if</span> ( ThisTnode-&gt;NumberOfChildren == 0 ) {
        TheMessage[0] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
        TheMessage[1] = NEXT_CYPHER;
        MessageLength = ThisTnode-&gt;DistanceToEndOfList + 2;
        Current = ThisTnode-&gt;Next;
        <span class="keyword">for</span> ( FillSpace = 2; FillSpace &lt; MessageLength; FillSpace++ ) {
            TheMessage[FillSpace] = Current-&gt;CrcDigest;
            <span class="keyword">if</span> ( TheMessage[FillSpace] == 0 ) printf("ZERO in CRC of Next.\n");
            Current = Current-&gt;Next;
        }
        
        TheMessage[MessageLength] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
        MessageLength += 1;
        
        ThisTnode-&gt;CrcDigest = LookupTableCrc((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)TheMessage, MessageLength&lt;&lt;2, Print);
        <span class="keyword">return</span>;
    }
    <span class="comment">// "ThisTnode" has a "Child" list, and also has following "Tnode"s in its own list.
</span>    TheMessage[0] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
    TheMessage[1] = CHILD_CYPHER;
    MessageLength = ThisTnode-&gt;NumberOfChildren + 2;
    Current = ThisTnode-&gt;Child;
    <span class="keyword">for</span> ( FillSpace = 2; FillSpace &lt; MessageLength; FillSpace++ ) {
        TheMessage[FillSpace] = Current-&gt;CrcDigest;
        <span class="keyword">if</span> ( TheMessage[FillSpace] == 0 ) printf("ZERO in CRC of BChild.\n");
        Current = Current-&gt;Next;
    }
    TheMessage[MessageLength] = NEXT_CYPHER;
    MessageLength += ThisTnode-&gt;DistanceToEndOfList + 1;
    Current = ThisTnode-&gt;Next;
    <span class="keyword">for</span> ( FillSpace += 1; FillSpace &lt; MessageLength; FillSpace++ ) {
        TheMessage[FillSpace] = Current-&gt;CrcDigest;
        <span class="keyword">if</span> ( TheMessage[FillSpace] == 0 ) printf("ZERO in CRC of BNext.\n");
        Current = Current-&gt;Next;
    }
    
    TheMessage[MessageLength] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ThisTnode-&gt;InternalValues;
    MessageLength += 1;
    
    ThisTnode-&gt;CrcDigest = LookupTableCrc((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)TheMessage, MessageLength&lt;&lt;2, Print);
    <span class="keyword">return</span>;
}

<span class="comment">// When calculating the "CrcDigest" of a "Tnode", its "Next" list and "Child" list must already have calculated "CrcDigest"s.
</span><span class="keyword">void</span> TnodeCalculateCrcDigestRecurse(TnodePtr ThisTnode){
    <span class="keyword">if</span> ( ThisTnode-&gt;Next != NULL ) TnodeCalculateCrcDigestRecurse(ThisTnode-&gt;Next);
    <span class="keyword">if</span> ( ThisTnode-&gt;Child != NULL ) TnodeCalculateCrcDigestRecurse(ThisTnode-&gt;Child);
    TnodeCalculateCrcDigest(ThisTnode, FALSE);
}

<span class="comment">// This function Dangles a "Tnode", but also recursively dangles every "Tnode" after and below it as well.
</span><span class="comment">// Dangling a "Tnode" means that it will be exculded from the final "DAWG" encoding.
</span><span class="comment">// By recursion, nodes that are not direct children will get dangled.
</span><span class="comment">// The function returns the total number of nodes dangled as a result.
</span><span class="keyword">int</span> TnodeDangleRecurse(TnodePtr ThisTnode){
    <span class="keyword">int</span> Result = 0;
    <span class="keyword">if</span> ( ThisTnode-&gt;Dangling == TRUE ) <span class="keyword">return</span> 0;
    <span class="keyword">if</span> ( ThisTnode-&gt;Protected == TRUE ) {
        printf("  There is NO scenario where Dangling a Protected node should happen.  ERROR, ERROR, ERROR.\n");
        <span class="keyword">return</span> 0;
    }
    <span class="keyword">if</span> ( (ThisTnode-&gt;Next) != NULL ) Result += TnodeDangleRecurse(ThisTnode-&gt;Next);
    <span class="keyword">if</span> ( (ThisTnode-&gt;Child) != NULL ) Result += TnodeDangleRecurse(ThisTnode-&gt;Child);
    <span class="keyword">if</span> ( ThisTnode-&gt;Dangling == FALSE )Result += 1;
    ThisTnode-&gt;Dangling = TRUE;
    <span class="keyword">return</span> Result;
}

<span class="comment">// This function "Protects" a node being directly referenced in the elimination process.
</span><span class="comment">// "Protected" "Tnode"s should NEVER be "Dangling".
</span><span class="comment">// Make sure to increment "ProtectedUnderCount" by "1" all the way up to the root "Tnode".
</span><span class="keyword">void</span> TnodeProtect(TnodePtr ThisTnode){
    TnodePtr Current = ThisTnode;
    <span class="keyword">if</span> ( ThisTnode-&gt;Protected == FALSE ) {
        ThisTnode-&gt;Protected = TRUE;
        <span class="keyword">while</span> ( Current != NULL ) {
            Current-&gt;ProtectedUnderCount += 1;
            Current = Current-&gt;ParentalUnit;
        }
    }
}

<span class="comment">// This function returns the pointer to the "Tnode" in a parallel list of "Tnodes" with the "LetterIndex" "ThisLetterIndex",
</span><span class="comment">// and returns "NULL" if the "Tnode" does not exist.
</span><span class="comment">// If the function returns "NULL", then an insertion is required.
</span>TnodePtr TnodeFindParaNode(TnodePtr ThisTnode, <span class="keyword">unsigned</span> <span class="keyword">char</span> ThisLetterIndex){
    TnodePtr Result = ThisTnode;
    <span class="keyword">if</span> ( ThisTnode == NULL ) <span class="keyword">return</span> NULL;
    <span class="keyword">if</span> ( Result-&gt;LetterIndex == ThisLetterIndex ) <span class="keyword">return</span> Result;
    <span class="keyword">while</span> ( Result-&gt;LetterIndex &lt; ThisLetterIndex ) {
        Result = Result-&gt;Next;
        <span class="keyword">if</span> ( Result == NULL ) <span class="keyword">return</span> NULL;
    }
    <span class="keyword">if</span> ( Result-&gt;LetterIndex == ThisLetterIndex ) <span class="keyword">return</span> Result;
    <span class="keyword">else</span> <span class="keyword">return</span> NULL;
}

<span class="comment">// This function inserts a new "Tnode" before a larger "LetterIndex" "Tnode" or at the end of a para list.
</span><span class="comment">// If the list does not exist, then it is put at the beginnung.  
</span><span class="comment">// The new "Tnode" has "ThisLetterIndex" in it.  "AboveTnode" is the "Tnode" 1 level above where the new node will be placed.
</span><span class="comment">// This function should never be passed a "NULL" pointer.  "ThisLetterIndex" should never exist in the "Child" "Tnode" list.
</span><span class="keyword">void</span> TnodeInsertParaNode(TnodePtr AboveTnode, <span class="keyword">unsigned</span> <span class="keyword">char</span> ThisLetterIndex, <span class="keyword">char</span> WordEnder, <span class="keyword">int</span> StartDepth){
    AboveTnode-&gt;NumberOfChildren += 1;
    TnodePtr Holder = NULL;
    TnodePtr Currently = NULL;
    <span class="comment">// Case 1: ParaList does not exist yet so start it.
</span>    <span class="keyword">if</span> ( AboveTnode-&gt;Child == NULL ) AboveTnode-&gt;Child = TnodeInit(ThisLetterIndex, NULL, WordEnder, AboveTnode-&gt;Level + 1,
    StartDepth, AboveTnode, TRUE, 0);
    <span class="comment">// Case 2: "ThisLetterIndex" should be the first in the ParaList.
</span>    <span class="keyword">else</span> <span class="keyword">if</span> ( AboveTnode-&gt;Child-&gt;LetterIndex &gt; ThisLetterIndex ) {
        Holder = AboveTnode-&gt;Child;
        <span class="comment">// The holder node is no longer a direct child so set it as such.
</span>        TnodeSetDirectChild(Holder, FALSE);
        AboveTnode-&gt;Child = TnodeInit(ThisLetterIndex, Holder, WordEnder, AboveTnode-&gt;Level + 1, StartDepth, AboveTnode, TRUE, TnodeDistanceToEndOfList(Holder) + 1);
        <span class="comment">// The parent node needs to be changed on what used to be the child. it is the Tnode in "Holder".
</span>        Holder-&gt;ParentalUnit = AboveTnode-&gt;Child;
    }
    <span class="comment">// Case 3: The ParaList exists and "ThisLetterIndex" is not first in the list.
</span>    <span class="keyword">else</span> {
        Currently = AboveTnode-&gt;Child;
        <span class="keyword">while</span> ( Currently-&gt;Next !=NULL ) {
            <span class="keyword">if</span> ( Currently-&gt;Next-&gt;LetterIndex &gt; ThisLetterIndex ) <span class="keyword">break</span>;
            Currently-&gt;DistanceToEndOfList += 1;
            Currently = Currently-&gt;Next;
        }
        Holder = Currently-&gt;Next;
        Currently-&gt;Next = TnodeInit(ThisLetterIndex, Holder, WordEnder, AboveTnode-&gt;Level + 1, StartDepth, Currently, FALSE, Currently-&gt;DistanceToEndOfList);
        Currently-&gt;DistanceToEndOfList += 1;
        <span class="keyword">if</span> ( Holder != NULL ) Holder-&gt;ParentalUnit = Currently-&gt;Next;
    }
}

<span class="keyword">struct</span> dawg {
    <span class="keyword">int</span> NumberOfTotalWords;
    <span class="keyword">int</span> NumberOfTotalNodes;
    TnodePtr First;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> dawg Dawg;
<span class="keyword">typedef</span> Dawg* DawgPtr;

<span class="comment">// Set up the parent nodes in the Dawg.
</span>DawgPtr DawgInit(<span class="keyword">void</span>){
    DawgPtr Result = (Dawg *)malloc(<span class="keyword">sizeof</span>(Dawg));
    Result-&gt;NumberOfTotalWords = 0;
    Result-&gt;NumberOfTotalNodes = 0;
    Result-&gt;First = TnodeInit('0', NULL, FALSE, 0, 0, NULL, FALSE, 0);
    <span class="keyword">return</span> Result;
}

<span class="comment">// Return the root node of "ThisDawg", which is a direct child of the "First" node.
</span>TnodePtr DawgRootNode(DawgPtr ThisDawg){
    <span class="keyword">return</span> TnodeChild(ThisDawg-&gt;First);
}

<span class="comment">// This function is responsible for adding "WordByIndexes" to the "Dawg" under its root node.
</span><span class="comment">// It returns the number of new nodes inserted.
</span><span class="keyword">int</span> TnodeDawgAddWord(TnodePtr ParentNode, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *WordByIndexes, <span class="keyword">int</span> WordSize){
    <span class="keyword">int</span> Result = 0;
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    TnodePtr HangPoint = NULL;
    TnodePtr Current = ParentNode;
    <span class="keyword">for</span> ( X = 0; X &lt; WordSize; X++){
        HangPoint = TnodeFindParaNode(TnodeChild(Current), WordByIndexes[X]);
        <span class="keyword">if</span> ( HangPoint == NULL ) {
            TnodeInsertParaNode(Current, WordByIndexes[X], (X == WordSize - 1 ? TRUE : FALSE), WordSize - X - 1);
            Result++;
            Current = TnodeFindParaNode(TnodeChild(Current), WordByIndexes[X]);
            <span class="keyword">for</span> ( Y = X + 1; Y &lt; WordSize; Y++ ) {
                TnodeInsertParaNode(Current, WordByIndexes[Y], (Y == WordSize - 1 ? TRUE : FALSE), WordSize - Y - 1);
                Result += 1;
                Current = TnodeChild(Current);
            }
            <span class="keyword">break</span>;
        }
        <span class="keyword">else</span> {
            <span class="keyword">if</span> ( TnodeMaxChildDepth(HangPoint) &lt; WordSize - X - 1 ) TnodeSetMaxChildDepth(HangPoint, WordSize - X - 1);
        }
        Current = HangPoint;
        <span class="comment">// The path for the "WordByIndexes" that we are trying to insert already exists,
</span>        <span class="comment">// so just make sure that the end flag is flying on the last node.
</span>        <span class="comment">// This should never happen if we are to add words in alphabetical order and increasing "WordByIndexes" length.
</span>        <span class="keyword">if</span> ( X == WordSize - 1 ) TnodeFlyEndOfWordFlag(Current);
    }
    <span class="keyword">return</span> Result;
}

<span class="comment">// Add "NewWord" to "ThisDawg", which at this point is a "Trie" with a lot of information in each node.
</span><span class="comment">// "NewWord" must not exist in "ThisDawg" already.
</span><span class="keyword">void</span> DawgAddWord(DawgPtr ThisDawg, <span class="keyword">unsigned</span> <span class="keyword">char</span> *NewWordByIndexes, <span class="keyword">int</span> WordLength){
    ThisDawg-&gt;NumberOfTotalWords += 1;
    ThisDawg-&gt;NumberOfTotalNodes += TnodeDawgAddWord(ThisDawg-&gt;First, NewWordByIndexes, WordLength);
}

<span class="comment">// This is a standard depth first inorder tree traversal.
</span><span class="comment">// Count un"Dangling" "Tnodes" into the 780 groups by "MaxChildDepth", "LetterIndex", and "DirectChild", then store values into "Tabulator".
</span><span class="keyword">void</span> TnodeGraphTabulateRecurse(TnodePtr ThisTnode, <span class="keyword">int</span> ***Tabulator){
    <span class="comment">// We will only ever be concerned with "Living" nodes.  "Dangling" Nodes will be eliminated, so don't count them.
</span>    <span class="keyword">if</span> ( ThisTnode-&gt;Dangling == FALSE ) {
        Tabulator[ThisTnode-&gt;MaxChildDepth][ThisTnode-&gt;LetterIndex][ThisTnode-&gt;DirectChild] += 1;
        <span class="comment">// Go Down if possible.
</span>        <span class="keyword">if</span> ( ThisTnode-&gt;Child != NULL ) TnodeGraphTabulateRecurse(TnodeChild(ThisTnode), Tabulator);
        <span class="comment">// Go Right if possible.
</span>        <span class="keyword">if</span> ( ThisTnode-&gt;Next != NULL ) TnodeGraphTabulateRecurse(TnodeNext(ThisTnode), Tabulator);
    }
}

<span class="comment">// Count the "Living" "Tnode"s into the 780 groups by "MaxChildDepth", "LetterIndex", and "DirectChild", then store values into "Count".
</span><span class="keyword">void</span> DawgGraphTabulate(DawgPtr ThisDawg, <span class="keyword">int</span> ***Count){
    <span class="keyword">if</span> ( ThisDawg-&gt;NumberOfTotalWords &gt; 0 ) {
        TnodeGraphTabulateRecurse(TnodeChild(ThisDawg-&gt;First), Count);
    }
}

<span class="comment">// Recursively replaces all redundant "Tnode"s under "ThisTnode", in one penetrating assult.
</span><span class="comment">// "DirectChild" "Tnode"s in a "Dangling" state have "ReplaceMeWith" set within them.
</span><span class="keyword">void</span> TnodeBlitzAttackRecurse(TnodePtr ThisTnode){
    <span class="keyword">if</span> ( ThisTnode-&gt;Next == NULL &amp;&amp; ThisTnode-&gt;Child == NULL ) <span class="keyword">return</span>;
    <span class="comment">// The first "Tnode" being eliminated will always be a "DirectChild".
</span>    <span class="keyword">if</span> ( ThisTnode-&gt;Child != NULL ) {
        <span class="comment">// The node is tagged to be excised, so replace it with "ReplaceMeWith".
</span>        <span class="keyword">if</span> ( ThisTnode-&gt;Child-&gt;Dangling == TRUE ) {
            ThisTnode-&gt;Child = ThisTnode-&gt;Child-&gt;ReplaceMeWith;
        }
        <span class="keyword">else</span> {
            TnodeBlitzAttackRecurse(ThisTnode-&gt;Child);
        }
    }
    <span class="keyword">if</span> ( ThisTnode-&gt;Next != NULL ){
        TnodeBlitzAttackRecurse(ThisTnode-&gt;Next);
    }
}

<span class="comment">// Replaces all pointers to "Dangling" "Child" "Tnodes" in the "ThisDawg" Trie with living ones.
</span><span class="keyword">void</span> BlitzkriegTrieAttack(DawgPtr ThisDawg){
    TnodeBlitzAttackRecurse(ThisDawg-&gt;First-&gt;Child);
}

<span class="comment">// A recursive function which Exchanges a single "Protected" "Tnode" under "ToDangle" with the corresponding "Tnode" under "ToKeep".
</span><span class="comment">// Remember to update "ProtectedUnderCount" for each line of "Tnodes" after the exchange.
</span><span class="keyword">void</span> TnodeExchangeProtectedNodeRecurse(TnodePtr ToDangle, TnodePtr ToKeep){
    <span class="keyword">int</span> ProtectedUnderCountParity;
    TnodePtr Holder;
    <span class="keyword">if</span> ( ToDangle-&gt;Protected == TRUE) {
        <span class="keyword">if</span> ( ToDangle-&gt;DirectChild == TRUE ) {
            <span class="comment">//printf("Protected ToDangle = DirectChild");
</span>            <span class="keyword">if</span> ( ToKeep-&gt;ReplaceMeWith == ToDangle ) {
                <span class="comment">//printf(" - Standard Crosslink");
</span>                ProtectedUnderCountParity = ToDangle-&gt;ProtectedUnderCount - ToKeep-&gt;ProtectedUnderCount;
                Holder = ToDangle-&gt;ParentalUnit;
                <span class="keyword">while</span> ( Holder != NULL ) {
                    Holder-&gt;ProtectedUnderCount -= ProtectedUnderCountParity;
                    Holder = Holder-&gt;ParentalUnit;
                }
                Holder = ToKeep-&gt;ParentalUnit;
                <span class="keyword">while</span> ( Holder != NULL ) {
                    Holder-&gt;ProtectedUnderCount += ProtectedUnderCountParity;
                    Holder = Holder-&gt;ParentalUnit;
                }
                (ToKeep-&gt;ParentalUnit)-&gt;Child = ToDangle;
                (ToDangle-&gt;ParentalUnit)-&gt;Child = ToKeep;
                Holder = ToKeep-&gt;ParentalUnit;
                ToKeep-&gt;ParentalUnit = ToDangle-&gt;ParentalUnit;
                ToDangle-&gt;ParentalUnit = Holder;
                <span class="keyword">return</span>;
            }
            <span class="comment">// This case is not possible.
</span>            <span class="keyword">else</span> {
                <span class="keyword">return</span>;
            }
        }
        <span class="comment">// The "Protected" "Tnode" is not a "DirectChild".
</span>        <span class="keyword">else</span> {
            <span class="keyword">if</span> ( ToKeep-&gt;Dangling == TRUE) {
                <span class="comment">//printf(" - ToKeep = Dangling - Something is FUCKED up.");
</span>                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span> {
                <span class="comment">//printf(" - ToKeep != Dangling");
</span>                ProtectedUnderCountParity = ToDangle-&gt;ProtectedUnderCount - ToKeep-&gt;ProtectedUnderCount;
                Holder = ToDangle-&gt;ParentalUnit;
                <span class="keyword">while</span> ( Holder != NULL ) {
                    Holder-&gt;ProtectedUnderCount -= ProtectedUnderCountParity;
                    Holder = Holder-&gt;ParentalUnit;
                }
                Holder = ToKeep-&gt;ParentalUnit;
                <span class="keyword">while</span> ( Holder != NULL ) {
                    Holder-&gt;ProtectedUnderCount += ProtectedUnderCountParity;
                    Holder = Holder-&gt;ParentalUnit;
                }
                (ToKeep-&gt;ParentalUnit)-&gt;Next = ToDangle;
                (ToDangle-&gt;ParentalUnit)-&gt;Next = ToKeep;
                Holder = ToKeep-&gt;ParentalUnit;
                ToKeep-&gt;ParentalUnit = ToDangle-&gt;ParentalUnit;
                ToDangle-&gt;ParentalUnit = Holder;
                <span class="keyword">return</span>;
            }
        }
    }
    <span class="keyword">if</span> ( ToDangle-&gt;Child != NULL ) TnodeExchangeProtectedNodeRecurse(ToDangle-&gt;Child, ToKeep-&gt;Child);
    <span class="keyword">if</span> ( ToDangle-&gt;Next != NULL ) TnodeExchangeProtectedNodeRecurse(ToDangle-&gt;Next, ToKeep-&gt;Next);
}

<span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</span>
<span class="comment">// A queue is required for breadth first traversal, and the rest is self-evident.
</span>
<span class="keyword">struct</span> breadthqueuenode {
    TnodePtr Element;
    <span class="keyword">struct</span> breadthqueuenode *Next;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> breadthqueuenode BreadthQueueNode;
<span class="keyword">typedef</span> BreadthQueueNode* BreadthQueueNodePtr;

<span class="keyword">void</span> BreadthQueueNodeSetNext(BreadthQueueNodePtr ThisBreadthQueueNode, BreadthQueueNodePtr Nexit){
        ThisBreadthQueueNode-&gt;Next = Nexit;
}

BreadthQueueNodePtr BreadthQueueNodeNext(BreadthQueueNodePtr ThisBreadthQueueNode){
        <span class="keyword">return</span> ThisBreadthQueueNode-&gt;Next;
}

TnodePtr BreadthQueueNodeElement(BreadthQueueNodePtr ThisBreadthQueueNode){
        <span class="keyword">return</span> ThisBreadthQueueNode-&gt;Element;
}

BreadthQueueNodePtr BreadthQueueNodeInit(TnodePtr NewElement){
    BreadthQueueNodePtr Result = (BreadthQueueNode *)malloc(<span class="keyword">sizeof</span>(BreadthQueueNode));
    Result-&gt;Element = NewElement;
    Result-&gt;Next = NULL;
    <span class="keyword">return</span> Result;
}

<span class="keyword">struct</span> breadthqueue {
    BreadthQueueNodePtr Front;
    BreadthQueueNodePtr Back;
    <span class="keyword">int</span> Size;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> breadthqueue BreadthQueue;
<span class="keyword">typedef</span> BreadthQueue* BreadthQueuePtr;

BreadthQueuePtr BreadthQueueInit(<span class="keyword">void</span>){
    BreadthQueuePtr Result = (BreadthQueue *)malloc(<span class="keyword">sizeof</span>(BreadthQueue));
    Result-&gt;Front = NULL;
    Result-&gt;Back = NULL;
    Result-&gt;Size = 0;
    <span class="keyword">return</span> Result;
}

<span class="keyword">void</span> BreadthQueuePush(BreadthQueuePtr ThisBreadthQueue, TnodePtr NewElemental){
    BreadthQueueNodePtr Noob = BreadthQueueNodeInit(NewElemental);
    <span class="keyword">if</span> ( (ThisBreadthQueue-&gt;Back) != NULL ) BreadthQueueNodeSetNext(ThisBreadthQueue-&gt;Back, Noob);
    <span class="keyword">else</span> ThisBreadthQueue-&gt;Front = Noob;
    ThisBreadthQueue-&gt;Back = Noob;
    (ThisBreadthQueue-&gt;Size) += 1;
}

TnodePtr BreadthQueuePop(BreadthQueuePtr ThisBreadthQueue){
    <span class="keyword">if</span> ( ThisBreadthQueue-&gt;Size == 0 ) <span class="keyword">return</span> NULL;
    <span class="keyword">if</span> ( ThisBreadthQueue-&gt;Size == 1 ) {
        ThisBreadthQueue-&gt;Back = NULL;
        ThisBreadthQueue-&gt;Size = 0;
        TnodePtr Result = (ThisBreadthQueue-&gt;Front)-&gt;Element;
        free(ThisBreadthQueue-&gt;Front);
        ThisBreadthQueue-&gt;Front = NULL;
        <span class="keyword">return</span> Result;
    }
    TnodePtr Result = (ThisBreadthQueue-&gt;Front)-&gt;Element;
    BreadthQueueNodePtr Holder = ThisBreadthQueue-&gt;Front;
    ThisBreadthQueue-&gt;Front = (ThisBreadthQueue-&gt;Front)-&gt;Next;
    free(Holder);
    ThisBreadthQueue-&gt;Size -= 1;
    <span class="keyword">return</span> Result;
}


<span class="comment">// For the "Tnode" "Dangling" process, arrange the "Tnodes" in the "Holder" array, with breadth-first traversal order.
</span><span class="keyword">void</span> BreadthQueuePopulateReductionArray(BreadthQueuePtr ThisBreadthQueue, TnodePtr Root, TnodePtr ****Holder){
    <span class="keyword">int</span> InsertionPosition[MAX][SIZE_OF_CHARACTER_SET][2];
    <span class="keyword">int</span> CMCD;
    <span class="keyword">char</span> CLetterIndex;
    <span class="keyword">char</span> CDCstatus;
    memset(InsertionPosition, 0, 2*MAX*SIZE_OF_CHARACTER_SET*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    TnodePtr Current = Root;
    <span class="comment">// Push the first row onto the queue.
</span>    <span class="keyword">while</span> ( Current != NULL ) {
        BreadthQueuePush(ThisBreadthQueue, Current);
        Current = Current-&gt;Next;
    }
    <span class="comment">// Initiate the pop followed by push all children loop.
</span>    <span class="keyword">while</span> ( (ThisBreadthQueue-&gt;Size) != 0 ) {
        Current = BreadthQueuePop(ThisBreadthQueue);
        CMCD = Current-&gt;MaxChildDepth;
        CLetterIndex = Current-&gt;LetterIndex;
        CDCstatus = Current-&gt;DirectChild;
        Holder[CMCD][CLetterIndex][CDCstatus][InsertionPosition[CMCD][CLetterIndex][CDCstatus]] = Current;
        InsertionPosition[CMCD][CLetterIndex][CDCstatus] += 1;
        Current = TnodeChild(Current);
        <span class="keyword">while</span> ( Current != NULL ) {
            BreadthQueuePush(ThisBreadthQueue, Current);
            Current = TnodeNext(Current);
        }
    }
}


<span class="comment">// It is of absolutely critical importance that only "DirectChild" nodes are pushed onto the queue as child nodes.
</span><span class="comment">// This will not always be the case.
</span><span class="comment">// In a DAWG, a child pointer may point to an internal node in a longer list.  Check for this.
</span><span class="keyword">int</span> BreadthQueueUseToIndex(BreadthQueuePtr ThisBreadthQueue, TnodePtr Root){
    <span class="keyword">int</span> IndexNow = 0;
    TnodePtr Current = Root;
    <span class="comment">// Push the first row onto the queue.
</span>    <span class="keyword">while</span> ( Current != NULL ) {
        BreadthQueuePush(ThisBreadthQueue, Current);
        Current = Current-&gt;Next;
    }
    <span class="comment">// Pop each element off of the queue and only push its children if its first "Child" is a "DirectChild", without a set "ArrayIndex".
</span>    <span class="comment">// Assign index if one has not been given to it yet.
</span>    <span class="keyword">while</span> ( (ThisBreadthQueue-&gt;Size) != 0 ) {
        Current = BreadthQueuePop(ThisBreadthQueue);
        <span class="comment">// A traversal of the Trie will never land on "Dangling" "Tnodes", but it will try to visit certain "Tnodes" many times.
</span>        <span class="comment">// Even if we only "Push" "Tnode"s without an assigned "ArrayIndex", many "Tnode"s will have this value set while in the queue.
</span>        <span class="keyword">if</span> ( TnodeArrayIndex(Current) == 0 ) {
            IndexNow += 1;
            TnodeSetArrayIndex(Current, IndexNow);
            Current = TnodeChild(Current);
            <span class="keyword">if</span> ( Current != NULL ) {
                <span class="comment">// The graph will lead to intermediate positions, but we cannot start numbering "Tnodes" from the middle of a list.
</span>                <span class="keyword">if</span> ( TnodeDirectChild(Current) == TRUE &amp;&amp; TnodeArrayIndex(Current) == 0 ) {
                    <span class="keyword">while</span> ( Current != NULL ) {
                        <span class="keyword">if</span> ( TnodeArrayIndex(Current) != 0 ) printf("Pushed Tnode with a non-zero ArrayIndex.\n");
                        BreadthQueuePush(ThisBreadthQueue, Current);
                        Current = Current-&gt;Next;
                    }
                }
            }
        }
    }
    <span class="keyword">return</span> IndexNow;
}

<span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</span>
<span class="comment">// Next and Child become indices.
</span><span class="keyword">struct</span> arraydnode{
    <span class="keyword">int</span> Next;
    <span class="keyword">int</span> Child;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> LetterIndex;
    <span class="keyword">char</span> EndOfWordFlag;
    <span class="keyword">char</span> Level;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> ChildCount;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> Position;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> arraydnode ArrayDnode;
<span class="keyword">typedef</span> ArrayDnode* ArrayDnodePtr;

<span class="keyword">void</span> ArrayDnodeInit(ArrayDnodePtr ThisArrayDnode, <span class="keyword">unsigned</span> <span class="keyword">char</span> Chap, <span class="keyword">int</span> Nextt, <span class="keyword">int</span> Childd, <span class="keyword">char</span> EndingFlag, <span class="keyword">char</span> Breadth, <span class="keyword">unsigned</span> <span class="keyword">char</span> Posit, <span class="keyword">unsigned</span> <span class="keyword">char</span> Ccount){
    ThisArrayDnode-&gt;LetterIndex = Chap;
    ThisArrayDnode-&gt;EndOfWordFlag = EndingFlag;
    ThisArrayDnode-&gt;Next = Nextt;
    ThisArrayDnode-&gt;Child = Childd;
    ThisArrayDnode-&gt;Level = Breadth;
    ThisArrayDnode-&gt;Position = Posit;
    ThisArrayDnode-&gt;ChildCount = Ccount;
}

<span class="keyword">void</span> ArrayDnodeTnodeTranspose(ArrayDnodePtr ThisArrayDnode, TnodePtr ThisTnode){
    ThisArrayDnode-&gt;LetterIndex = ThisTnode-&gt;LetterIndex;
    ThisArrayDnode-&gt;EndOfWordFlag = ThisTnode-&gt;EndOfWordFlag;
    ThisArrayDnode-&gt;Level = ThisTnode-&gt;Level;
    ThisArrayDnode-&gt;Position = ThisTnode-&gt;DistanceToEndOfList;
    ThisArrayDnode-&gt;ChildCount = ThisTnode-&gt;NumberOfChildren;
    <span class="keyword">if</span> ( ThisTnode-&gt;Next == NULL ) ThisArrayDnode-&gt;Next = 0;
    <span class="keyword">else</span> ThisArrayDnode-&gt;Next = (ThisTnode-&gt;Next)-&gt;ArrayIndex;
    <span class="keyword">if</span> ( ThisTnode-&gt;Child == NULL ) ThisArrayDnode-&gt;Child = 0;
    <span class="keyword">else</span> ThisArrayDnode-&gt;Child = (ThisTnode-&gt;Child)-&gt;ArrayIndex;
}

<span class="keyword">struct</span> arraydawg {
    <span class="keyword">int</span> NumberOfStrings;
    ArrayDnodePtr DawgArray;
    <span class="keyword">int</span> First;
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> arraydawg ArrayDawg;
<span class="keyword">typedef</span> ArrayDawg* ArrayDawgPtr;

<span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</span><span class="comment">// This function is the core of the DAWG creation procedure.  Pay close attention to the order of the steps involved.
</span>
ArrayDawgPtr ArrayDawgInit(<span class="keyword">unsigned</span> <span class="keyword">char</span> **Dictionary, <span class="keyword">int</span> *SegmentLenghts){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">int</span> Z;
    <span class="keyword">int</span> W;
    
    printf("Step 0 - Allocate the framework for the intermediate Array-Data-Structure.\n");
    <span class="comment">// Dynamically allocate the upper Data-Structure.
</span>    ArrayDawgPtr Result = (ArrayDawgPtr)malloc(<span class="keyword">sizeof</span>(ArrayDawg));
    <span class="comment">// Set NumberOfStrings.
</span>    Result-&gt;NumberOfStrings = 0;
    <span class="keyword">for</span> ( X = MIN; X &lt;= MAX ; X++ ) Result-&gt;NumberOfStrings += SegmentLenghts[X];

    printf("\nStep 1 - Create a TemporaryTrie and begin filling it with the |%d| words.\n", Result-&gt;NumberOfStrings);
    <span class="comment">/// Create a Temp Trie structure and then feed in the given dictionary.
</span>    DawgPtr TemporaryTrie = DawgInit();
    <span class="keyword">for</span> ( Y = MIN; Y &lt;= MAX; Y++ ) {
        <span class="keyword">for</span> ( X = 0; X &lt; SegmentLenghts[Y]; X++ ) {
            DawgAddWord(TemporaryTrie, &amp;(Dictionary[Y][Y*X]), Y);
        }
    }

    printf("\nStep 2 - Finished filling TemporaryTrie, so calculate the InternalValues comparison integers.\n");
    
    TnodeCalculateInternalValuesRecurse(DawgRootNode(TemporaryTrie));
    
    printf("\nStep 3 - Eliminate recursion by calculating the recursive CrcDigest for each Tnode.\n");
    
    TnodeCalculateCrcDigestRecurse(DawgRootNode(TemporaryTrie));
    
    printf("\nStep 4 - Count Tnodes into 780 groups, segmented by MaxChildDepth, Letter, and DirectChild.\n");
    
    <span class="comment">// Allocate 3D arrays of "int"s to count the "Tnodes" into groups.
</span>    <span class="keyword">int</span> ***NodeGroupCounter= (<span class="keyword">int</span> ***)malloc(MAX*<span class="keyword">sizeof</span>(<span class="keyword">int</span> **));
    <span class="keyword">int</span> ***NodeGroupCounterInit = (<span class="keyword">int</span> ***)malloc(MAX*<span class="keyword">sizeof</span>(<span class="keyword">int</span> **));
    
    <span class="keyword">for</span> ( X = 0; X &lt; MAX; X++ ) {
        NodeGroupCounterInit[X] = (<span class="keyword">int</span> **)malloc(SIZE_OF_CHARACTER_SET*<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));
        NodeGroupCounter[X] = (<span class="keyword">int</span> **)malloc(SIZE_OF_CHARACTER_SET*<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            NodeGroupCounterInit[X][Y] = (<span class="keyword">int</span> *)calloc(2, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
            NodeGroupCounter[X][Y] = (<span class="keyword">int</span> *)calloc(2, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
        }
    }
    
    DawgGraphTabulate(TemporaryTrie, NodeGroupCounterInit);
    
    printf("\nStep 5 - Initial Tnode counting is complete, so display results:\n");
    <span class="keyword">int</span> TotalNodeSum = 0;
    <span class="keyword">int</span> MaxGroupSize = 0;
    <span class="keyword">int</span> CurrentGroupSize;
    <span class="keyword">for</span> ( X = 0; X &lt; MAX; X++ ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            CurrentGroupSize = NodeGroupCounterInit[X][Y][0] + NodeGroupCounterInit[X][Y][1];
            TotalNodeSum += CurrentGroupSize;
            <span class="keyword">if</span> ( CurrentGroupSize &gt; MaxGroupSize ) MaxGroupSize = CurrentGroupSize;
        }
    }
    
    printf("\n  Total Tnode Count For The Raw-Trie = |%d|, MaxGroupSize = |%d| \n", TotalNodeSum, MaxGroupSize);
    <span class="comment">// We will have exactly enough space for all of the Tnode pointers.
</span>
    printf("\nStep 6 - Allocate a 4-D array of Tnode pointers to tag redundant Tnodes for replacement.\n");
    
    TnodePtr ****HolderOfAllTnodePointers = (TnodePtr ****)malloc(MAX*<span class="keyword">sizeof</span>(TnodePtr ***));
    <span class="keyword">for</span> ( X = 0; X &lt; MAX; X++ ) {
        HolderOfAllTnodePointers[X] = (TnodePtr ***)malloc(SIZE_OF_CHARACTER_SET*<span class="keyword">sizeof</span>(TnodePtr **));
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            HolderOfAllTnodePointers[X][Y] = (TnodePtr **)malloc(3*<span class="keyword">sizeof</span>(TnodePtr *));
            CurrentGroupSize = NodeGroupCounterInit[X][Y][0] + NodeGroupCounterInit[X][Y][1];
            <span class="keyword">if</span> ( CurrentGroupSize ) {
                HolderOfAllTnodePointers[X][Y][2] = (TnodePtr *)malloc(CurrentGroupSize*<span class="keyword">sizeof</span>(TnodePtr));
                <span class="keyword">if</span> ( NodeGroupCounterInit[X][Y][0] ) HolderOfAllTnodePointers[X][Y][0] = HolderOfAllTnodePointers[X][Y][2];
                <span class="keyword">else</span> HolderOfAllTnodePointers[X][Y][0] = NULL;
                <span class="keyword">if</span> ( NodeGroupCounterInit[X][Y][1] ) {
                    HolderOfAllTnodePointers[X][Y][1] = HolderOfAllTnodePointers[X][Y][2] + NodeGroupCounterInit[X][Y][0];
                }
                <span class="keyword">else</span> HolderOfAllTnodePointers[X][Y][1] = NULL;
            }
            <span class="keyword">else</span> {
                HolderOfAllTnodePointers[X][Y][0] = NULL;
                HolderOfAllTnodePointers[X][Y][1] = NULL;
                HolderOfAllTnodePointers[X][Y][2] = NULL;
                
            }
        }
    }
    
    <span class="comment">// A breadth-first traversal is used when populating the final array.
</span>    <span class="comment">// It is then much more likely for living "Tnode"s to appear first, if we fill "HolderOfAllTnodePointers" breadth first.
</span>
    printf("\nStep 7 - Populate the 4 dimensional Tnode pointer array, keeping DirectChild nodes closer to the end.\n");
    <span class="comment">// Use a breadth first traversal to populate the "HolderOfAllTnodePointers" array.
</span>    BreadthQueuePtr Populator = BreadthQueueInit();
    BreadthQueuePopulateReductionArray(Populator, DawgRootNode(TemporaryTrie), HolderOfAllTnodePointers);
    free(Populator);

    <span class="comment">// "HolderOfAllTnodePointers" Population procedure is complete.
</span>    
    printf("\nStep 8 - Use the stable Merge-Sort algorithm to sort [MaxChildDepth][LetterIndex] groups by CrcDigest values.\n");
    
    TnodePtr *SupplementalArray = (TnodePtr *)malloc(MaxGroupSize*<span class="keyword">sizeof</span>(TnodePtr));
    
    <span class="keyword">for</span> ( X = 0; X &lt; MAX; X++ ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            TnodeArrayMergeSortRecurse(HolderOfAllTnodePointers[X][Y][2], (NodeGroupCounterInit[X][Y][0] + NodeGroupCounterInit[X][Y][1]), SupplementalArray);
        }
    }
    free(SupplementalArray);
    
    <span class="comment">// Flag all of the reduntant "Tnode"s, and store a "ReplaceMeWith" "Tnode" reference inside the "Dangling" "Tnode"s.
</span>    <span class="comment">// "Tnode"s are compared using their "CrcDigest" values, which incorporate information from entire branch structures.
</span>    <span class="keyword">int</span> NumberDangled;
    <span class="keyword">int</span> DangledNow;
    <span class="keyword">int</span> DirectDangled;
    <span class="keyword">int</span> TotalDangled = 0;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> CurrentCrcDigest;
    TnodePtr CorrectReplacementTnode;
    
    printf("\nStep 9 - Tag entire Tnode branch structures as Dangling - Elimination begins with DirectChild Tnodes and filters down:\n");
    printf("\n  This procedure is at the very heart of DAWG genesis, where the Blitzkrieg Algorithm shines with CRC, and Tnode Segmentation.\n");
    printf("  Seperate groups exist for each [MaxChildDepth]-[LetterIndex] pair.\n");
    printf("  Groups of similar Tnodes, are now sorted by 3 values, [BreadthFirst], [DirectChild], [CrcDigest].\n");
    printf("  This Blitzkrieg Scheme means that each redundant Tnode patch will directly follow its living Tnode replacement.\n");
    printf("\n  ---------------------------------------------------------------------------------------------------------------------------\n");
    <span class="comment">// "X" is the current "MaxChildDepth".
</span>    <span class="keyword">for</span> ( X = MAX - 1; X &gt;= 0; X-- ) {
        NumberDangled = 0;
        DirectDangled = 0;
        <span class="comment">// "Y" is the current "LetterIndex", starting at "0".
</span>        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            CurrentGroupSize = NodeGroupCounterInit[X][Y][0] + NodeGroupCounterInit[X][Y][1];
            CorrectReplacementTnode = NULL;
            CurrentCrcDigest = 0;
            <span class="comment">// "Z" Will move through the current "Tnode" group, identifying the "CorrectReplacementTnode".
</span>            <span class="keyword">for</span> ( Z = 0; Z &lt; CurrentGroupSize; Z++ ) {
                <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][Z]-&gt;Dangling ) <span class="keyword">continue</span>;
                CorrectReplacementTnode = HolderOfAllTnodePointers[X][Y][2][Z];
                CurrentCrcDigest = CorrectReplacementTnode-&gt;CrcDigest;
                <span class="comment">// "W" Tracks the "Tnodes" that will be Dangled, and shifts "Z" when it finds a new "CrcDigest".
</span>                <span class="keyword">for</span> ( W = Z + 1; W &lt; CurrentGroupSize; W++ ) {
                    <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][W]-&gt;CrcDigest == CurrentCrcDigest) {
                        <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][W]-&gt;Dangling ) <span class="keyword">continue</span>;
                        <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][W]-&gt;DirectChild == FALSE ) <span class="keyword">continue</span>;
                        <span class="comment">// If the potential replacement "Tnode" has "Protected" "Tnode"s under it, then proceed to exchange the offending branch.
</span>                        <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][W]-&gt;ProtectedUnderCount ) {
                            printf("  Attempting to Dangle Protected, Count = |%d|", HolderOfAllTnodePointers[X][Y][2][W]-&gt;ProtectedUnderCount);
                            TnodeExchangeProtectedNodeRecurse(HolderOfAllTnodePointers[X][Y][2][W], CorrectReplacementTnode);
                            <span class="comment">//printf(", after swap Count = |%d|.\n", HolderOfAllTnodePointers[X][Y][2][W]-&gt;ProtectedUnderCount);
</span>                            <span class="keyword">if</span> ( HolderOfAllTnodePointers[X][Y][2][W]-&gt;ProtectedUnderCount ) {
                                printf("\n  Exchanging the first protected Tnode did not solve the problem.  Fix the Exchange procedure.\n");
                                <span class="keyword">break</span>;
                            }
                            <span class="keyword">else</span> printf(" - FIXED.\n");
                        }
                        HolderOfAllTnodePointers[X][Y][2][W]-&gt;ReplaceMeWith = CorrectReplacementTnode;
                        TnodeProtect(CorrectReplacementTnode);
                        DirectDangled += 1;
                        DangledNow = TnodeDangleRecurse(HolderOfAllTnodePointers[X][Y][2][W]);
                        NumberDangled += DangledNow;
                    }
                    <span class="keyword">else</span> {
                        Z = W - 1;
                        <span class="keyword">break</span>;
                    }
                }
            }
        }
        printf("  DirectDangled |%5d| Tnodes, and |%5d| through recursion - MCD|%2d|\n", DirectDangled, NumberDangled, X);
        TotalDangled += NumberDangled;
    }
    printf("  ---------------------------------------------------------------------------------------------------------------------------\n\n");
    
    <span class="keyword">int</span> NumberOfLivingNodes;
    printf("  |%6d| = Original # of Tnodes.\n", TotalNodeSum);    
    printf("  |%6d| = Dangled # of Tnodes.\n", TotalDangled);
    printf("  |%6d| = Remaining # of Tnodes.\n", NumberOfLivingNodes = TotalNodeSum - TotalDangled);

    printf("\nStep 10 - Count the number of living Tnodes by traversing the Raw-Trie to check the Dangling numbers.\n\n");
    DawgGraphTabulate(TemporaryTrie, NodeGroupCounter);
    <span class="keyword">int</span> TotalDangledCheck = 0;
    <span class="keyword">for</span> ( X = 0; X &lt; MAX; X++ ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            <span class="keyword">for</span> ( Z = 0; Z &lt; 2; Z++ ) {
                TotalDangledCheck += (NodeGroupCounterInit[X][Y][Z] - NodeGroupCounter[X][Y][Z]);
            }
        }
    }
    <span class="keyword">if</span> ( TotalDangled == TotalDangledCheck ) printf("  Tnode Dangling count is consistent, TotalDangledCheck = |%d|.\n", TotalDangledCheck);
    <span class="keyword">else</span> printf("  MISMATCH for Tnode Dangling count.\n");
    
    printf("\nstep 11 - Using the BlitzkriegTrieAttack, substitute Dangling Tnodes with internal \"ReplaceMeWith\" values.\n");
    <span class="comment">// Node replacement has to take place before indices are set up, so nothing points to redundant nodes.
</span>    <span class="comment">// This step is absolutely critical.  Attack the Raw Trie using the Blitzkrieg single penetration.  Then Index.
</span>    BlitzkriegTrieAttack(TemporaryTrie);
    printf("\n  Killing complete.\n");

    printf("\nStep 12 - Blitzkrieg Attack is victorious, so assign array indicies to all living Tnodes using a Breadth-First-Queue.\n");
    BreadthQueuePtr OrderMatters = BreadthQueueInit();
    <span class="comment">// The Breadth-First-Queue must assign an index value to each living "Tnode" only once.
</span>    <span class="comment">// Make sure to feed the root Tnode of "TemporaryTrie" into the "BreadthQueueUseToIndex()" function.
</span>    <span class="keyword">int</span> IndexCount = BreadthQueueUseToIndex(OrderMatters, DawgRootNode(TemporaryTrie));
    free(OrderMatters);
    printf("\n  Index assignment is now complete.\n");
    printf("\n  |%d| = NumberOfLivingNodes from after the Dangling process.\n", NumberOfLivingNodes);
    printf("  |%d| = IndexCount from the breadth-first assignment function.\n", IndexCount);

    <span class="comment">// Allocate the space needed to store the "DawgArray".
</span>    Result-&gt;DawgArray = (ArrayDnodePtr)calloc((NumberOfLivingNodes + 1), <span class="keyword">sizeof</span>(ArrayDnode));
    <span class="keyword">int</span> IndexFollow = 0;
    <span class="keyword">int</span> IndexFollower = 0;
    <span class="keyword">int</span> TransposeCount = 0;
    <span class="comment">// Roll through the pointer arrays and use the "ArrayDnodeTnodeTranspose" function to populate it.
</span>    <span class="comment">// Set the dummy entry at the beginning of the array.
</span>    ArrayDnodeInit(&amp;(Result-&gt;DawgArray[0]), 0, 0, 0, 0, 0, 0, 0);
    Result-&gt;First = 1;

    printf("\nStep 13 - Populate the new Working-Array-Dawg structure, used to verify validity and create the final integer-graph-encodings.\n");
    <span class="comment">// Scroll through "HolderOfAllTnodePointers" and look for un"Dangling" "Tnodes", if so then transpose them into "Result-&gt;DawgArray".
</span>    <span class="keyword">for</span> ( X = MAX - 1; X &gt;= 0; X-- ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            <span class="keyword">for</span> (Z = 0; Z &lt; 2; Z++ ) {
                <span class="keyword">for</span> ( W = 0; W &lt; NodeGroupCounterInit[X][Y][Z]; W++ ) {
                    <span class="keyword">if</span> ( TnodeDangling(HolderOfAllTnodePointers[X][Y][Z][W]) == FALSE ) {
                        IndexFollow = TnodeArrayIndex(HolderOfAllTnodePointers[X][Y][Z][W]);
                        ArrayDnodeTnodeTranspose(&amp;(Result-&gt;DawgArray[IndexFollow]), HolderOfAllTnodePointers[X][Y][Z][W]);
                        TransposeCount += 1;
                        <span class="keyword">if</span> ( IndexFollow &gt; IndexFollower ) IndexFollower = IndexFollow;
                    }
                }
            }
        }
    }
    printf("\n  |%d| = IndexFollower, which is the largest index assigned in the Working-Array-Dawg.\n", IndexFollower);
    printf("  |%d| = TransposeCount, holds the number of Tnodes transposed into the Working-Array-Dawg.\n", TransposeCount);
    printf("  |%d| = NumberOfLivingNodes.  Make sure that these three values are equal, because they must be.\n", NumberOfLivingNodes);
    <span class="keyword">if</span> ( (IndexFollower == TransposeCount) &amp;&amp; (IndexFollower == NumberOfLivingNodes) ) printf("\n  Equality assertion passed.\n");
    <span class="keyword">else</span> printf("\n  Equality assertion failed.\n");
    
    <span class="comment">// Conduct dynamic-memory-cleanup and free the whole Raw-Trie, which is no longer needed.
</span>    <span class="keyword">for</span> ( X = MAX - 1; X &gt;= 0; X-- ) {
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            <span class="keyword">for</span> ( W = 0; W &lt; (NodeGroupCounterInit[X][Y][0] + NodeGroupCounterInit[X][Y][1]); W++ ) {
                free(HolderOfAllTnodePointers[X][Y][2][W]);
            }
            free(HolderOfAllTnodePointers[X][Y][2]);
            free(HolderOfAllTnodePointers[X][Y]);
        }
        free(HolderOfAllTnodePointers[X]);
    }
    free(HolderOfAllTnodePointers);
    free(TemporaryTrie);
    
    printf("\nStep 14 - Creation of the traditional-DAWG is complete, so store it in a binary file for use.\n");
    
    FILE *Data;
    Data = fopen( TRADITIONAL_DAWG_DATA,"wb" );
    <span class="comment">// The "NULL" node in position "0" must be counted now.
</span>    <span class="keyword">int</span> CurrentNodeInteger = NumberOfLivingNodes + 1;
    <span class="comment">// It is critical, especially in a binary file, that the first integer written to the file be the number of nodes stored in the file.
</span>    fwrite( &amp;CurrentNodeInteger, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), 1, Data );
    <span class="comment">// Write the "NULL" node to the file first.
</span>    CurrentNodeInteger = 0;
    fwrite( &amp;CurrentNodeInteger, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), 1, Data );
    <span class="keyword">for</span> ( X = 1; X &lt;= NumberOfLivingNodes ; X++ ){
        CurrentNodeInteger = (Result-&gt;DawgArray)[X].Child;
        CurrentNodeInteger &lt;&lt;= CHILD_BIT_SHIFT;
        CurrentNodeInteger |= CharacterSet[Result-&gt;DawgArray[X].LetterIndex];
        <span class="keyword">if</span> ( Result-&gt;DawgArray[X].EndOfWordFlag ) CurrentNodeInteger |= END_OF_WORD_BIT_MASK;
        <span class="keyword">if</span> ( !Result-&gt;DawgArray[X].Next ) CurrentNodeInteger |= END_OF_LIST_BIT_MASK;
        fwrite(&amp;CurrentNodeInteger, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), 1, Data);
    }
    fclose(Data);
    printf( "\n  The Traditional-DAWG-Encoding data file is now written.\n" );
    
    printf("\nStep 15 - Output a text file with all the node information explicitly layed out.\n");
    
    FILE *Text;
    Text = fopen(TRADITIONAL_DAWG_TEXT_DATA,"w");

    <span class="keyword">char</span> TheNodeInBinary[32+5+1];
    
    <span class="keyword">int</span> CompleteThirtyTwoBitNode;
    
    fprintf(Text, "Behold, the |%d| Traditional DAWG nodes are decoded below:\r\n\r\n", NumberOfLivingNodes);
    
    <span class="comment">// We are now ready to output to the text file, and the "Main" binary data file.
</span>    <span class="keyword">for</span> ( X = 1; X &lt;= NumberOfLivingNodes ; X++ ){
        CompleteThirtyTwoBitNode = (Result-&gt;DawgArray)[X].Child;
        CompleteThirtyTwoBitNode &lt;&lt;= CHILD_BIT_SHIFT;
        CompleteThirtyTwoBitNode |= CharacterSet[Result-&gt;DawgArray[X].LetterIndex];
        <span class="keyword">if</span> ( (Result-&gt;DawgArray)[X].EndOfWordFlag == TRUE ) CompleteThirtyTwoBitNode |= END_OF_WORD_BIT_MASK;
        <span class="keyword">if</span> ( (Result-&gt;DawgArray)[X].Next == 0 ) CompleteThirtyTwoBitNode |= END_OF_LIST_BIT_MASK;
        ConvertIntNodeToBinaryString(CompleteThirtyTwoBitNode, TheNodeInBinary);
        fprintf(Text, "N%6d-%s, DistanceToEndOfList|%2d|", X, TheNodeInBinary, Result-&gt;DawgArray[X].Position);
        fprintf(Text, ", NumberOfChildren|%2d|", Result-&gt;DawgArray[X].ChildCount);
        fprintf(Text, ", Lev|%2d|", (Result-&gt;DawgArray)[X].Level);
        fprintf(Text, ", {'%c',%d,%6d", CharacterSet[Result-&gt;DawgArray[X].LetterIndex], Result-&gt;DawgArray[X].EndOfWordFlag, Result-&gt;DawgArray[X].Next);
        fprintf(Text, ",%6d}", (Result-&gt;DawgArray)[X].Child);
        fprintf(Text, ".\r\n");
        <span class="keyword">if</span> ( CompleteThirtyTwoBitNode == 0 ) printf("\n  Error in node encoding process.\n");
    }
    
    fprintf(Text, "\r\nNumber Of Living Nodes |%d| Plus The NULL Node.\r\n\r\n", NumberOfLivingNodes);

    fclose(Text);

    <span class="keyword">return</span> Result;
}

<span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</span>


<span class="keyword">int</span> main(){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> ThisLine[INPUT_LIMIT] = "\0";
    printf("\n  Hit \"Enter\" to begin the Blitzkrieg Attack Algorithm:\n\n  Be dazzled, your DAWG will be created in the PAST:");
    fgets(ThisLine, INPUT_LIMIT, stdin);
    <span class="comment">// All of the words of similar length will be stored sequentially in the same array so that there will be (MAX + 1)  arrays in total.
</span>    <span class="comment">// The Smallest length of a string is assumed to be 2.
</span>    <span class="keyword">unsigned</span> <span class="keyword">char</span> *AllWordsInEnglish[MAX + 1];
    <span class="keyword">for</span> ( X = 0; X &lt; (MAX + 1); X++ ) AllWordsInEnglish[X] = NULL;
    
    <span class="comment">// Read the precompiled lookup-table from "CRC-32.dat" directly into "TheLookupTable".
</span>    FILE *TableFile;
    TableFile = fopen(LOOKUP_TABLE_DATA, "rb");
    fread(TheLookupTable, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), TWO_UP_EIGHT, TableFile);
    fclose(TableFile);
    
    FILE *Input;
    Input = fopen(RAW_LEXICON,"r");
    <span class="keyword">int</span> FirstLineIsSize;
    <span class="keyword">int</span> LineLength;
    
    fgets(ThisLine, INPUT_LIMIT, Input);
    CutOffExtraChars(ThisLine);
    FirstLineIsSize = StringToPositiveInt(ThisLine);
    
    printf("\n  FirstLineIsSize = Number-Of-Words = |%d|\n", FirstLineIsSize);
    <span class="keyword">int</span> DictionarySizeIndex[MAX + 1];
    <span class="keyword">for</span> ( X = 0; X &lt;= MAX; X++ ) DictionarySizeIndex[X] = 0;
    <span class="keyword">char</span> **LexiconInRam = (<span class="keyword">char</span>**)malloc(FirstLineIsSize*<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)); 
    
    <span class="comment">// The first line is the Number-Of-Words, so read them all into RAM, temporarily.
</span>    <span class="keyword">for</span> ( X = 0; X &lt; FirstLineIsSize; X++ ) {
        fgets(ThisLine, INPUT_LIMIT, Input);
        CutOffExtraChars(ThisLine);
        MakeMeAllCapital(ThisLine);
        <span class="keyword">if</span> ( !TestForValidWord(ThisLine) ) printf("Invalid Word @ |%d|-|%s|\n", X, ThisLine);
        LineLength = strlen(ThisLine);
        <span class="keyword">if</span> ( LineLength &lt;= MAX ) DictionarySizeIndex[LineLength] += 1;
        <span class="keyword">else</span> {
            printf("The word in position |%d| is too long.  EXIT.\n", X);
            <span class="keyword">return</span> 0;
        }
        LexiconInRam[X] = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)malloc((LineLength + 1)*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));
        strcpy(LexiconInRam[X], ThisLine);
    }
    printf("\n  Word-List.txt is now in RAM.\n");
    <span class="comment">// Allocate enough space to hold all of the words in "unsigned char" arrays holding character indexes.
</span>    <span class="keyword">for</span> ( X = 2; X &lt; (MAX + 1); X++ ) AllWordsInEnglish[X] = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)malloc(X*DictionarySizeIndex[X]*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));
    
    <span class="keyword">int</span> CurrentTracker[MAX + 1];
    memset(CurrentTracker, 0, (MAX + 1)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="keyword">unsigned</span> <span class="keyword">char</span> CurrentWordByIndex[MAX];
    <span class="keyword">int</span> CurrentLength;
    <span class="comment">// Copy all of the words into the "LetterIndex" format "AllWordsInEnglish" array.
</span>    <span class="keyword">for</span> ( X = 0; X &lt; FirstLineIsSize; X++ ) {
        CurrentLength = strlen(LexiconInRam[X]);
        <span class="comment">// Convert each string from its temporary ram location into the "LetterIndex" format, and copy that into "AllWordsInEnglish".
</span>        LettersToIndexConversion(LexiconInRam[X], CurrentWordByIndex);
        memcpy(AllWordsInEnglish[CurrentLength] + CurrentTracker[CurrentLength]*CurrentLength, CurrentWordByIndex, CurrentLength);
        CurrentTracker[CurrentLength] += 1;
    }
    printf("\n  The words are now stored in an array according to length.\n\n");
    <span class="comment">// Make sure that the counting has resulted in all of the strings being placed correctly.
</span>    <span class="keyword">for</span> ( X = 0; X &lt; (MAX + 1); X++ ) {
        <span class="keyword">if</span> ( DictionarySizeIndex[X] == CurrentTracker[X] ) printf("  |%2d| Letter word count = |%5d| is verified.\n", X, CurrentTracker[X]);
        <span class="keyword">else</span> printf("  Something went wrong with |%2d| letter words.\n", X);
    }
    
    <span class="comment">// Free the the initial dynamically allocated memory.
</span>    <span class="keyword">for</span> ( X = 0; X &lt; FirstLineIsSize; X++ ) free(LexiconInRam[X]);
    free(LexiconInRam);
    
    printf("\n  Begin Creator init function.\n\n");
    
    ArrayDawgPtr Adoggy = ArrayDawgInit(AllWordsInEnglish, DictionarySizeIndex);
    
    printf("\nStep 16 - Display the Mask-Format for the DAWG int-nodes:\n\n");
    
    <span class="keyword">char</span> Something[32+5+1];
    
    ConvertIntNodeToBinaryString(CHILD_INDEX_BIT_MASK, Something);
    printf("  %s - CHILD_INDEX_BIT_MASK\n", Something);
    
    ConvertIntNodeToBinaryString(END_OF_WORD_BIT_MASK, Something);
    printf("  %s - END_OF_WORD_BIT_MASK\n", Something);
    
    ConvertIntNodeToBinaryString(END_OF_LIST_BIT_MASK, Something);
    printf("  %s - END_OF_LIST_BIT_MASK\n", Something);
    
    ConvertIntNodeToBinaryString(LETTER_BIT_MASK, Something);
    printf("  %s - LETTER_BIT_MASK\n", Something);
    
    <span class="keyword">return</span> 0;
}
</pre>


</td>
</tr>
</tbody></table>
<br>
<br>



<table align="CENTER" cellspacing="5" cellpadding="5" bordercolor="008000" border="8">
<caption>Blitzkrieg_Functionality_Test.c</caption>
<tbody><tr>
<td align="LEFT">

<pre style="font-family:courier;font-size:10pt"><span class="comment">// This program tests the validity of a Blitzkrieg DAWG file, and demonstrates the new Dawg-Node configuration.
</span><span class="comment">// Updated on Monday, December 29, 2011.
</span>
<span class="pp">#include</span> &lt;stdlib.h&gt;
<span class="pp">#include</span> &lt;stdio.h&gt;
<span class="pp">#include</span> &lt;string.h&gt;

<span class="pp">#define</span> MAX 15
<span class="pp">#define</span> MAX_INPUT 120
<span class="pp">#define</span> BIG_IT_UP -32
<span class="pp">#define</span> LOWER_IT 32
<span class="pp">#define</span> SIZE_OF_CHARACTER_SET 26
<span class="pp">#define</span> WILD_CARD '?'
<span class="pp">#define</span> DAWG_DATA "Traditional_Dawg_For_Word-List.dat"
<span class="pp">#define</span> WORD_LIST_OUTPUT "New_Dawg_Word_List.txt"

<span class="comment">// These values define the format of the "Dawg" node encoding.
</span><span class="pp">#define</span> CHILD_BIT_SHIFT 10
<span class="pp">#define</span> END_OF_WORD_BIT_MASK 0X00000200
<span class="pp">#define</span> END_OF_LIST_BIT_MASK 0X00000100
<span class="pp">#define</span> LETTER_BIT_MASK 0X000000FF

<span class="comment">// Define the boolean type as an enumeration.
</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {FALSE = 0, TRUE = 1} Bool;
<span class="keyword">typedef</span> Bool* BoolPtr;

<span class="comment">// When reading strings from a file, the new-line character is appended, and this macro will remove it before processing.
</span><span class="pp">#define</span> CUT_OFF_NEW_LINE(string) (string[strlen(string) - 1] = '\0')

<span class="comment">// For speed, define these two simple functions as macros.  They modify the "LettersToWorkWith" string in the recursive anagrammer.
</span><span class="pp">#define</span> REMOVE_CHAR_FROM_STRING(thestring, theposition, shiftsize) ( memmove(thestring + theposition, thestring + theposition + 1, shiftsize) )
<span class="pp">#define</span> INSERT_CHAR_IN_STRING(ts, tp, thechar, shiftsize) ( (memmove(ts + tp + 1, ts + tp, shiftsize)), (ts[tp] = thechar) )

<span class="comment">// These are the predefined characters that exist in the DAWG data file.
</span><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> CharacterSet[SIZE_OF_CHARACTER_SET] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };

<span class="comment">// Enter the graph at the correct position without scrolling through a predefined list of level "0" nodes.
</span><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> EntryNodeIndex[SIZE_OF_CHARACTER_SET] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
 20, 21, 22, 23, 24, 25, 26 };

<span class="comment">// This function converts any lower case letters in the string "RawWord", into capitals, so that the whole string is made of capital letters.
</span><span class="keyword">void</span> MakeMeAllCapital(<span class="keyword">char</span> *RawWord){
    <span class="keyword">int</span> X;
    <span class="keyword">for</span> ( X = 0; X &lt; strlen(RawWord); X++ ){
        <span class="keyword">if</span> ( RawWord[X] &gt;= 'a' &amp;&amp; RawWord[X] &lt;= 'z' ) RawWord[X] = RawWord[X] + BIG_IT_UP;
    }
}

<span class="comment">// This function removes any char from "ThisString" which does not exist in "CharacterSet".
</span><span class="keyword">void</span> RemoveIllegalChars(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ThisString){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">int</span> Length = strlen(ThisString);
    <span class="keyword">for</span> ( X = 0; X &lt; Length; X++ ) {
        <span class="keyword">if</span> ( ThisString[X] == WILD_CARD ) <span class="keyword">goto</span> CheckNextPosition;
        <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
            <span class="keyword">if</span> ( ThisString[X] == CharacterSet[Y] ) <span class="keyword">goto</span> CheckNextPosition;
        }
        <span class="comment">// The "char" in position "X" is illegal.
</span>        memmove(ThisString + X, ThisString + X + 1, Length - X);
        X -= 1;
        Length -= 1;
        CheckNextPosition:;
    }
}

<span class="comment">// Return the index position of character "ThisChar", as it appears in "CharacterSet", and it must exist in the set.
</span><span class="keyword">unsigned</span> <span class="keyword">char</span> CharToIndexConversion(<span class="keyword">unsigned</span> <span class="keyword">char</span> ThisChar){
    <span class="keyword">int</span> Y;
    <span class="keyword">if</span> ( ThisChar == WILD_CARD ) <span class="keyword">return</span> 255;
    <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
        <span class="keyword">if</span> ( ThisChar == CharacterSet[Y] ) <span class="keyword">return</span> Y;
    }
}

<span class="comment">// This is a simple Bubble Sort.
</span><span class="keyword">void</span> Alphabetize(<span class="keyword">unsigned</span> <span class="keyword">char</span> *Word){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">int</span> WildCardCount = 0;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> WorkingChar;
    <span class="keyword">int</span> WordSize = strlen(Word);
    <span class="keyword">for</span>( X = 1; X &lt; WordSize; X++ ) {
        <span class="keyword">for</span>( Y = 0; Y &lt;= (WordSize - X - 1); Y++ ) {
            <span class="keyword">if</span> ( CharToIndexConversion(Word[Y]) &gt; CharToIndexConversion(Word[Y + 1]) ) {
                WorkingChar = Word[Y + 1];
                Word[Y + 1] = Word[Y];
                Word[Y] = WorkingChar;
            }
        }
    }
    <span class="keyword">if</span> ( Word[WordSize - 1] == WILD_CARD ) {
        <span class="keyword">for</span> ( X = WordSize - 1; X &gt;= 0; X-- ) {
            <span class="keyword">if</span> ( Word[X] == WILD_CARD ) WildCardCount += 1;
        }
        memmove(Word + WildCardCount, Word, WordSize - WildCardCount);
        memset(Word, WILD_CARD, WildCardCount);
    }
}

<span class="comment">// Define the "Dawg" functionality as macros for speed.  "DAWG_CHILD()" Now uses only a single bit shift operation.
</span><span class="pp">#define</span> DAWG_LETTER(thearray, theindex) (thearray[theindex]&amp;LETTER_BIT_MASK)
<span class="pp">#define</span> DAWG_END_OF_WORD(thearray, theindex) (thearray[theindex]&amp;END_OF_WORD_BIT_MASK)
<span class="pp">#define</span> DAWG_NEXT(thearray, theindex) ((thearray[theindex]&amp;END_OF_LIST_BIT_MASK)? 0: theindex + 1)
<span class="pp">#define</span> DAWG_CHILD(thearray, theindex) (thearray[theindex]&gt;&gt;CHILD_BIT_SHIFT)

<span class="comment">// A recursive depth first traversal of "TheDawg" lexicon to produce a readable wordlist in "TheStream".
</span><span class="keyword">void</span> DawgTraverseLexiconRecurse(<span class="keyword">unsigned</span> <span class="keyword">int</span> *TheDawg, <span class="keyword">int</span> CurrentIndex, <span class="keyword">int</span> FillThisPosition,
 <span class="keyword">char</span> *WorkingString, <span class="keyword">int</span> *TheCount, FILE *TheStream){
    <span class="keyword">int</span> PassOffIndex;
    WorkingString[FillThisPosition] = DAWG_LETTER(TheDawg, CurrentIndex);
    <span class="keyword">if</span> ( DAWG_END_OF_WORD(TheDawg, CurrentIndex) ) {
        *TheCount += 1;
        WorkingString[FillThisPosition + 1] = '\0';
        <span class="comment">// Include the Windows Carriage Return char.
</span>        fprintf(TheStream, "|%6d|-|%-15s|\r\n", *TheCount, WorkingString);
    }
    <span class="keyword">if</span> ( PassOffIndex = DAWG_CHILD(TheDawg, CurrentIndex) ) DawgTraverseLexiconRecurse(TheDawg,
    PassOffIndex, FillThisPosition + 1, WorkingString, TheCount, TheStream);
    <span class="keyword">if</span> ( PassOffIndex = DAWG_NEXT(TheDawg, CurrentIndex) ) DawgTraverseLexiconRecurse(TheDawg,
    PassOffIndex, FillThisPosition, WorkingString, TheCount, TheStream);
}

<span class="comment">// Move through "ThisDawg" lexicon, and print the words into "ThisStream".
</span><span class="keyword">void</span> DawgTraverseLexicon(<span class="keyword">unsigned</span> <span class="keyword">int</span> *ThisDawg, FILE *ThisStream){
    <span class="keyword">char</span> *BufferWord = (<span class="keyword">char</span>*)malloc((MAX + 1)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));
    <span class="keyword">int</span> *WordCounter = (<span class="keyword">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    *WordCounter = 0;
    <span class="comment">// Include the Windows Carriage Return char.
</span>    fprintf(ThisStream, "This is the lexicon contained in the file |%s|.\r\n\r\n", DAWG_DATA);
    DawgTraverseLexiconRecurse(ThisDawg, 1, 0, BufferWord, WordCounter, ThisStream);
    free(BufferWord);
    free(WordCounter);
}

<span class="comment">// This function is the core component of this program.
</span><span class="comment">// It requires that "UnusedChars" be in alphabetical order because the tradition Dawg is a list based structure.
</span><span class="keyword">void</span> DawgAnagrammerRecurse(<span class="keyword">int</span> *DawgOfWar, <span class="keyword">int</span> CurrentIndex, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ToyWithMe,
 <span class="keyword">int</span> FillThisPosition, <span class="keyword">unsigned</span> <span class="keyword">char</span> *UnusedChars, <span class="keyword">int</span> SizeOfBank, <span class="keyword">int</span> *ForTheCounter, Bool WildCard){
    <span class="keyword">int</span> X;
    <span class="keyword">char</span> PreviousChar = '\0';
    <span class="keyword">char</span> CurrentChar;
    <span class="keyword">int</span> TempIndex = DAWG_CHILD(DawgOfWar, CurrentIndex);
    
    ToyWithMe[FillThisPosition] = DAWG_LETTER(DawgOfWar, CurrentIndex) + (WildCard? LOWER_IT: 0);
    
    <span class="keyword">if</span> ( DAWG_END_OF_WORD(DawgOfWar, CurrentIndex) ) {
        *ForTheCounter += 1;
        ToyWithMe[FillThisPosition + 1] = '\0';
        printf("|%4d| - |%-15s|%s\n", *ForTheCounter, ToyWithMe, SizeOfBank? "\0": "--&gt; TRUE ANAGRAM");
    }
    <span class="keyword">if</span> ( (SizeOfBank &gt; 0) &amp;&amp; (TempIndex != 0) ) {
        <span class="keyword">for</span> ( X = 0; X &lt; SizeOfBank; X++ ) {
            CurrentChar = UnusedChars[X];
            <span class="keyword">if</span> ( CurrentChar == PreviousChar ) <span class="keyword">continue</span>;
            <span class="keyword">if</span> ( CurrentChar == WILD_CARD ) {
                REMOVE_CHAR_FROM_STRING(UnusedChars, X, SizeOfBank - X);
                <span class="keyword">while</span> ( TempIndex ) {
                    DawgAnagrammerRecurse(DawgOfWar, TempIndex, ToyWithMe, FillThisPosition + 1,
                     UnusedChars, SizeOfBank - 1, ForTheCounter, TRUE);
                    TempIndex = DAWG_NEXT(DawgOfWar, TempIndex);
                }
                INSERT_CHAR_IN_STRING(UnusedChars, X, CurrentChar, SizeOfBank - X);
                TempIndex = DAWG_CHILD(DawgOfWar, CurrentIndex);
            }
            <span class="keyword">else</span> {
                <span class="keyword">do</span> {
                    <span class="keyword">if</span> ( CurrentChar == DAWG_LETTER(DawgOfWar, TempIndex) ) {
                        REMOVE_CHAR_FROM_STRING(UnusedChars, X, SizeOfBank - X);
                        DawgAnagrammerRecurse(DawgOfWar, TempIndex, ToyWithMe, FillThisPosition + 1,
                         UnusedChars, SizeOfBank - 1, ForTheCounter, FALSE);
                        INSERT_CHAR_IN_STRING(UnusedChars, X, CurrentChar, SizeOfBank - X);
                        TempIndex = DAWG_NEXT(DawgOfWar, TempIndex);
                        <span class="keyword">break</span>;
                    }
                    <span class="keyword">else</span> <span class="keyword">if</span> ( CurrentChar &lt; DAWG_LETTER(DawgOfWar, TempIndex) ) <span class="keyword">break</span>;
                } <span class="keyword">while</span> ( TempIndex = DAWG_NEXT(DawgOfWar, TempIndex) );
            }
            <span class="keyword">if</span> ( TempIndex == 0 ) <span class="keyword">break</span>;
            PreviousChar = CurrentChar;
        }
    }
}

<span class="comment">// This function uses "MasterDawg" to determine the words that can be made from the letters in "CharBank".
</span><span class="comment">// The words will be displayed in alphabetical order according to "CharacterSet[]".
</span><span class="comment">// The return value is the total number of words found.
</span><span class="keyword">int</span> DawgAnagrammer(<span class="keyword">int</span> *MasterDawg, <span class="keyword">unsigned</span> <span class="keyword">char</span> * CharBank){
    <span class="keyword">int</span> X;
    <span class="keyword">int</span> Y;
    <span class="keyword">int</span> Result;
    <span class="keyword">int</span> BankSize = strlen(CharBank);
    <span class="keyword">int</span> *ForTheCount = (<span class="keyword">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="keyword">unsigned</span> <span class="keyword">char</span> *TheWordSoFar = (<span class="keyword">char</span>*)malloc((MAX + 1)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));
    <span class="keyword">unsigned</span> <span class="keyword">char</span> *LettersToWorkWith = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)malloc(MAX_INPUT*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));
    <span class="keyword">unsigned</span> <span class="keyword">char</span> PreviousChar = '\0';
    <span class="keyword">unsigned</span> <span class="keyword">char</span> CurrentChar;
    <span class="keyword">int</span> NumberOfLetters;
    <span class="keyword">int</span> CurrentEntryNode;
    strcpy(LettersToWorkWith, CharBank);
    Alphabetize(LettersToWorkWith);
    NumberOfLetters = strlen(LettersToWorkWith);
    
    *ForTheCount = 0;
    <span class="keyword">for</span> ( X = 0; X &lt; BankSize; X++ ) {
        CurrentChar = LettersToWorkWith[X];
        <span class="comment">// Move to the next letter if we have already processed the "CurrentChar".
</span>        <span class="keyword">if</span> ( CurrentChar == PreviousChar ) <span class="keyword">continue</span>;
        <span class="keyword">if</span> ( CurrentChar == WILD_CARD ) {
            REMOVE_CHAR_FROM_STRING(LettersToWorkWith, X, NumberOfLetters - X);
            <span class="keyword">for</span> ( Y = 0; Y &lt; SIZE_OF_CHARACTER_SET; Y++ ) {
                <span class="keyword">if</span> ( EntryNodeIndex[Y] ) {
                    DawgAnagrammerRecurse(MasterDawg, EntryNodeIndex[Y], TheWordSoFar, 0, LettersToWorkWith,
                    NumberOfLetters - 1, ForTheCount, TRUE);
                }
            }
            INSERT_CHAR_IN_STRING(LettersToWorkWith, X, CurrentChar, NumberOfLetters - X);
            PreviousChar = CurrentChar;
            <span class="keyword">continue</span>;
        }
        <span class="comment">// Make sure not to enter the graph if NO words begin with "CurrentChar".
</span>        CurrentEntryNode = EntryNodeIndex[CharToIndexConversion(CurrentChar)];
        <span class="keyword">if</span> ( !CurrentEntryNode ) {
            PreviousChar = CurrentChar;
            <span class="keyword">continue</span>;
        }
        REMOVE_CHAR_FROM_STRING(LettersToWorkWith, X, NumberOfLetters - X);
        DawgAnagrammerRecurse(MasterDawg, CurrentEntryNode, TheWordSoFar, 0, LettersToWorkWith,
        NumberOfLetters - 1, ForTheCount, FALSE);
        INSERT_CHAR_IN_STRING(LettersToWorkWith, X, CurrentChar, NumberOfLetters - X);
        PreviousChar = CurrentChar;
    }
    Result = *ForTheCount;
    free(ForTheCount);
    free(TheWordSoFar);
    free(LettersToWorkWith);
    <span class="keyword">return</span> Result;
}

<span class="keyword">int</span> main() {
    <span class="keyword">int</span> NumberOfNodes;
    <span class="keyword">int</span> *TheDawgArray;
    FILE *Lexicon;
    FILE *WordList;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> *DecisionInput;
    Bool FetchData = TRUE;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> FirstChar;
    <span class="keyword">int</span> InputSize;
    
    DecisionInput = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)malloc(MAX_INPUT*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));
    Lexicon = fopen(DAWG_DATA, "rb");
    fread(&amp;NumberOfNodes, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), 1, Lexicon);
    printf("\n  The lexicon DAWG contains |%d| nodes.\n", NumberOfNodes);
    TheDawgArray = (<span class="keyword">int</span> *)malloc(NumberOfNodes*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    fread(TheDawgArray, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), NumberOfNodes, Lexicon);
    fclose(Lexicon);
    printf("\n  \"%s\" has been read into memory.\n\n", DAWG_DATA);
    
    <span class="comment">// This program relies on a compressed lexicon data file,
</span>    <span class="comment">// so allow the user to see a readable word list in an output file.
</span>    <span class="keyword">while</span> ( FetchData == TRUE ) {
        printf("\nWould you like to print the Dawg word list into a text file?(Y/N):  ");
        fgets(DecisionInput, MAX_INPUT, stdin);
        FirstChar = DecisionInput[0];
        <span class="keyword">if</span> ( FirstChar == 'Y' || FirstChar == 'y' ) {
            WordList = fopen(WORD_LIST_OUTPUT, "w");
            DawgTraverseLexicon(TheDawgArray, WordList);
            fclose(WordList);
            FetchData = FALSE;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> ( FirstChar == 'N' || FirstChar == 'n' ) FetchData = FALSE;
    }
    FetchData = TRUE;
    
    <span class="comment">// Now the user can enter strings of letters for anagramming, to see the words that can be made from them.
</span>    <span class="keyword">while</span> ( FetchData == TRUE ) {
        printf("\nEnter anagram letters ( At least 2 letters) - (WildCard = ?):  ");
        fgets(DecisionInput, MAX_INPUT, stdin);
        CUT_OFF_NEW_LINE(DecisionInput);
        MakeMeAllCapital(DecisionInput);
        RemoveIllegalChars(DecisionInput);
        InputSize = strlen(DecisionInput);
        <span class="keyword">if</span> ( InputSize &gt;= 2 ) {
            printf("\nThis is the set of letters that you just input |%s|.\n\n", DecisionInput);
            printf("\n|%d| Words were found in the lexicon Dawg.\n", DawgAnagrammer(TheDawgArray, DecisionInput));
        }
        <span class="keyword">else</span> FetchData = FALSE;
    }
    printf("\nThank you for testing the new Blitzkrieg DAWG encoding.  GAME OVER.\n\n");
    <span class="keyword">return</span> 0;
}
</pre>


</td>
</tr>
</tbody></table>
<br>
<br>



<hr width="90%">
<a name="contact"></a>
<font color="#008000">
<h2 align="CENTER">Contact Information</h2>
</font>
<br>
<br>

Contact: JohnPaul Adamovsky � ( logarithm69@hotmail.com ) - Please feel free to ask me questions.
<br>
<br>
<br>
Phone: (416) 231-7577
<br>
<br>
<br>
This is the mark of my trade...
<br>
<br>
<br>
<b>All The Very Best,</b>
<br>
<br>
JohnPaul Adamovsky

<img src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/Trademark.jpg" width="700" height="178" align="MIDDLE">

<p align="CENTER">
<a href="http://www.digits.net/" target="_blank">
<img src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/a.png" alt="Hit Counter by Digits" border="0">
</a> 
</p>

<center>
<a href="http://www.isc.ro/"><b>Internet Scrabble Club</b></a> 
- The best place to play scrabble online
</center>    

<br>
<hr width="90%">
<p align="CENTER">
|&nbsp;<a href="#top">Go&nbsp;Back&nbsp;to&nbsp;the&nbsp;Top</a>&nbsp;|
</p>

<p align="CENTER">
<a href="http://www.digits.com/"><img src="Directed%20Acyclic%20Word%20Graph%20or%20DAWG_files/wc.gif" width="157" vspace="2" hspace="2" height="43" border="1"></a>
</p>

</body></html>